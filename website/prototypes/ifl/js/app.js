// Generated by CoffeeScript 1.3.3
(function() {
  var App, IFLLoader, namespace,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  namespace = function(name, values) {
    var key, subpackage, target, value, _i, _len, _ref;
    if (this.hasOwnProperty("window")) {
      target = window;
    } else if (this.hasOwnProperty("exports")) {
      target = exports;
    } else {
      target = this;
    }
    if (name.length > 0) {
      _ref = name.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subpackage = _ref[_i];
        target = target[subpackage] || (target[subpackage] = {});
      }
    }
    for (key in values) {
      value = values[key];
      target[key] = value;
    }
    return target;
  };

  namespace('', {
    namespace: namespace
  });

  namespace("ifl", {
    IFLVertexAttribute: {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    }
  });

  namespace("ifl", {
    IFLLoader: IFLLoader = (function() {

      IFLLoader.prototype.library = null;

      IFLLoader.prototype.callback = null;

      IFLLoader.prototype.callbackProgress = null;

      IFLLoader.prototype.worker = null;

      IFLLoader.prototype.convertTextureIndex = 0;

      IFLLoader.prototype.length = 0;

      IFLLoader.prototype.texCache = null;

      IFLLoader.prototype.matCache = null;

      IFLLoader.prototype.t = 0;

      IFLLoader.prototype.url = null;

      function IFLLoader() {
        var _this = this;
        this.worker = new Worker('js/libs/workers.js');
        this.worker.onmessage = function(event) {
          var loaded, subtype, total;
          switch (event.data.type) {
            case "console":
              return console[event.data.action](event.data.msg);
            case "progress":
              loaded = event.data.data.progress;
              total = event.data.data.total;
              return subtype = event.data.subtype;
            default:
              return _this[event.data.callback](event.data.data);
          }
        };
        this.texCache = {};
        this.matCache = {};
      }

      IFLLoader.prototype.load = function(url, callback, callbackProgress) {
        var xhr,
          _this = this;
        this.url = url;
        this.callback = callback;
        this.callbackProgress = callbackProgress;
        this.length = 0;
        xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          var response, _ref, _ref1;
          if (xhr.readyState === xhr.DONE) {
            if (xhr.status === 200 || xhr.status === 0) {
              response = (_ref = xhr.response) != null ? _ref : xhr.mozResponseArrayBuffer;
              _this.decompressLibrary(response);
            } else {
              console.error("[ IFLLoader ]: Couldn't load [ " + url + " ] [ " + xhr.status + " ]");
            }
          } else if (xhr.readyState === xhr.LOADING) {
            if (_this.callbackProgress != null) {
              if (!(_this.length != null)) {
                _this.length = xhr.getResponseHeader("Content-Length");
              }
              response = (_ref1 = xhr.response) != null ? _ref1 : xhr.mozResponseArrayBuffer;
              _this.callbackProgress({
                total: _this.length,
                loaded: response ? response.length : NaN
              });
            }
          } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
            _this.length = xhr.getResponseHeader("Content-Length");
          }
        };
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        return xhr.send(null);
      };

      IFLLoader.prototype.decompressLibrary = function(data) {
        this.t = new Date().getTime();
        return this.worker.postMessage({
          type: "inflate",
          data: data,
          callback: "parseLibrary"
        });
      };

      IFLLoader.prototype.parseLibrary = function(data) {
        console.log(("[" + this.url + "] decompression time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        return this.worker.postMessage({
          type: "convert_library",
          data: data,
          callback: "onLibraryParsed"
        });
      };

      IFLLoader.prototype.onLibraryParsed = function(data) {
        var content, func, _i, _len, _ref;
        this.library = data;
        for (func in this.IFLLibraryFuncs) {
          this.library[func] = this.IFLLibraryFuncs[func];
        }
        this.library._contentByID = {};
        _ref = this.library._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          content = _ref[_i];
          this.library._contentByID[content._reference.id] = content;
        }
        console.log(("[" + this.url + "] library parse time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        return this.convertTextures();
      };

      IFLLoader.prototype.convertTextures = function() {
        var bmp, i, _i, _ref, _ref1;
        for (i = _i = _ref = this.convertTextureIndex, _ref1 = this.library._content.length; _i < _ref1; i = _i += 1) {
          if (this.library._content[i].iflType === "IFLBitmap") {
            bmp = this.library._content[i];
            this.convertTextureIndex = i + 1;
            if (bmp._hasOriginalByteArray) {
              this.worker.postMessage({
                type: "parse_jpg",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            } else {
              this.worker.postMessage({
                type: "convert_argb",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            }
            return;
          }
        }
        return this.createModel();
      };

      IFLLoader.prototype.onTextureConverted = function(data) {
        this.library._content[this.convertTextureIndex - 1].converted = data;
        return this.convertTextures();
      };

      IFLLoader.prototype.createModel = function() {
        var root, rootObject, rootObjects, _i, _len;
        console.log(("[" + this.url + "] convert textures time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        root = new THREE.Object3D();
        rootObjects = this.library.getRootNodes();
        for (_i = 0, _len = rootObjects.length; _i < _len; _i++) {
          rootObject = rootObjects[_i];
          root.add(this.convertNode(rootObject));
        }
        console.log(("[" + this.url + "] convert node time: ") + (new Date().getTime() - this.t) / 1000);
        this.callback(root);
        this.worker.postMessage({
          type: "kill"
        });
      };

      IFLLoader.prototype.convertNode = function(iflnode) {
        var child, childID, mat, retEntity, _i, _len, _ref;
        switch (iflnode.iflType) {
          case "IFLMesh":
            retEntity = this.convertMesh(iflnode);
            break;
          default:
            retEntity = new THREE.Object3D();
        }
        retEntity.name = iflnode._reference.id;
        retEntity.matrix = this.convertMatrix4(iflnode._transformMatrix);
        retEntity.scale.getScaleFromMatrix(retEntity.matrix);
        mat = new THREE.Matrix4().extractRotation(retEntity.matrix);
        retEntity.rotation.setEulerFromRotationMatrix(retEntity.matrix, retEntity.eulerOrder);
        retEntity.position.getPositionFromMatrix(retEntity.matrix);
        _ref = iflnode.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          child = this.library.getContent(childID.id);
          if (child) {
            retEntity.add(this.convertNode(child));
          }
        }
        return retEntity;
      };

      IFLLoader.prototype.convertMatrix4 = function(m) {
        return new THREE.Matrix4(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
      };

      IFLLoader.prototype.convertMesh = function(iflmesh) {
        var bone, color_length, colors, geometry, index, isSkinnedMesh, material, normals, positions, ret, skinIndices, skinWeights, tangents, uvs, _i, _len, _ref;
        positions = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.POSITION];
        uvs = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.UV];
        normals = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.NORMALS];
        tangents = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.TEX_TANGENTS];
        colors = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.COLOR];
        color_length = 0;
        if (colors != null) {
          color_length = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.COLOR];
        }
        skinWeights = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_WEIGHTS];
        skinIndices = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_INDICES];
        isSkinnedMesh = skinWeights && skinIndices;
        if (positions.length < 65535 && !isSkinnedMesh && iflmesh.subMeshes.length === 1) {
          geometry = this.convertBufferGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        } else {
          geometry = this.convertGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        }
        geometry.hasTangents = tangents != null;
        material = iflmesh.subMeshes.length === 1 ? geometry.materials[0] : new THREE.MeshFaceMaterial;
        material.skinning = isSkinnedMesh;
        if (isSkinnedMesh) {
          ret = new THREE.SkinnedMesh(geometry, material);
        } else {
          ret = new THREE.Mesh(geometry, material);
        }
        if (isSkinnedMesh) {
          _ref = ret.geometry.bones;
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            bone = _ref[index];
            ret.boneInverses[index] = bone.invBindMatrix;
          }
        }
        ret.castShadow = ret.receiveShadow = true;
        return ret;
      };

      IFLLoader.prototype.convertBufferGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var geometry, indexBuffer;
        geometry = new THREE.BufferGeometry;
        indexBuffer = iflmesh.subMeshes[0].indexBuffer._rawData;
        geometry.attributes = {};
        geometry.attributes.index = {
          itemSize: 1,
          array: new Int16Array(indexBuffer.length),
          numItems: indexBuffer.length
        };
        geometry.attributes.index.array.set(indexBuffer);
        geometry.attributes.position = {
          itemSize: 3,
          array: new Float32Array(positions.length),
          numItems: positions.length
        };
        geometry.attributes.position.array.set(positions);
        if (uvs) {
          geometry.attributes.uv = {
            itemSize: 2,
            array: new Float32Array(uvs.length),
            numItems: uvs.length
          };
          geometry.attributes.uv.array.set(uvs);
        }
        if (normals) {
          geometry.attributes.normal = {
            itemSize: 3,
            array: new Float32Array(normals.length),
            numItems: normals.length
          };
          geometry.attributes.normal.array.set(normals);
        }
        if (colors) {
          geometry.attributes.color = {
            itemSize: color_length,
            array: new Float32Array(colors.length),
            numItems: colors.length
          };
          geometry.attributes.color.array.set(colors);
        }
        if (tangents) {
          geometry.attributes.tangent = {
            itemSize: 3,
            array: new Float32Array(tangents.length),
            numItems: tangents.length
          };
          geometry.attributes.tangent.array.set(tangents);
        }
        geometry.offsets = [
          {
            start: 0,
            count: indexBuffer.length,
            index: 0
          }
        ];
        geometry.materials = [this.convertMaterial(iflmesh.subMeshes[0])];
        return geometry;
      };

      IFLLoader.prototype.convertGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var cachedColors, cachedNormals, cachedTangents, cachedUVs, face, faceIndex, fakeUV, fvUVs, geometry, i, i1, i12, i13, i14, i2, i22, i23, i24, i3, i32, i33, i34, ib, ibi, material, second, stepSize, subMesh, subMeshIndex, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _step;
        console.log("mesh " + iflmesh._reference.id + " not BufferGeometry");
        geometry = new THREE.Geometry;
        cachedUVs = [];
        cachedNormals = [];
        cachedTangents = [];
        cachedColors = [];
        if (positions) {
          for (i = _i = 0, _ref = positions.length; _i < _ref; i = _i += 3) {
            geometry.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
          }
        } else {
          return new THREE.Object3D();
        }
        if (isSkinnedMesh) {
          stepSize = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.JOINT_INDICES];
          if (stepSize <= 2) {
            for (i = _j = 0, _ref1 = skinIndices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += stepSize) {
              second = Math.floor(i + stepSize / 2);
              geometry.skinWeights.push(new THREE.Vector4(skinWeights[i], skinWeights[second], 0, 0));
              geometry.skinIndices.push(new THREE.Vector4(skinIndices[i], skinIndices[second], 0, 0));
            }
          }
          geometry.bones = this.convertBones(iflmesh);
          geometry.animation = this.convertAnimations(geometry.bones, iflmesh);
        }
        fakeUV = new THREE.UV(0, 0);
        _ref2 = iflmesh.subMeshes;
        for (subMeshIndex = _k = 0, _len = _ref2.length; _k < _len; subMeshIndex = ++_k) {
          subMesh = _ref2[subMeshIndex];
          material = this.convertMaterial(subMesh);
          material.skinning = isSkinnedMesh;
          geometry.materials.push(material);
          ib = subMesh.indexBuffer._rawData;
          for (ibi = _l = 0, _len1 = ib.length, _step = 3; _l < _len1; ibi = _l += _step) {
            i1 = ib[ibi];
            i2 = ib[ibi + 1];
            i3 = ib[ibi + 2];
            i12 = i1 * 2;
            i22 = i2 * 2;
            i32 = i3 * 2;
            i13 = i1 * 3;
            i23 = i2 * 3;
            i33 = i3 * 3;
            i14 = i1 * 4;
            i24 = i2 * 4;
            i34 = i3 * 4;
            face = new THREE.Face3(i1, i2, i3, null, null, subMeshIndex);
            faceIndex = geometry.faces.length;
            fvUVs = geometry.faceVertexUvs[0][faceIndex] = [];
            if (uvs != null) {
              fvUVs.push(cachedUVs[i12] ? cachedUVs[i12] : cachedUVs[i12] = new THREE.UV(uvs[i12], uvs[i12 + 1]));
              fvUVs.push(cachedUVs[i22] ? cachedUVs[i22] : cachedUVs[i22] = new THREE.UV(uvs[i22], uvs[i22 + 1]));
              fvUVs.push(cachedUVs[i32] ? cachedUVs[i32] : cachedUVs[i32] = new THREE.UV(uvs[i32], uvs[i32 + 1]));
            }
            if (normals != null) {
              face.vertexNormals.push(cachedNormals[i13] ? cachedNormals[i13] : cachedNormals[i13] = new THREE.Vector3(normals[i13], normals[i13 + 1], normals[i13 + 2]));
              face.vertexNormals.push(cachedNormals[i23] ? cachedNormals[i23] : cachedNormals[i23] = new THREE.Vector3(normals[i23], normals[i23 + 1], normals[i23 + 2]));
              face.vertexNormals.push(cachedNormals[i33] ? cachedNormals[i33] : cachedNormals[i33] = new THREE.Vector3(normals[i33], normals[i33 + 1], normals[i33 + 2]));
            }
            if (tangents != null) {
              face.vertexTangents.push(cachedTangents[i13] ? cachedTangents[i13] : cachedTangents[i13] = new THREE.Vector4(tangents[i13], tangents[i13 + 1], tangents[i13 + 2], 1));
              face.vertexTangents.push(cachedTangents[i23] ? cachedTangents[i23] : cachedTangents[i23] = new THREE.Vector4(tangents[i23], tangents[i23 + 1], tangents[i23 + 2], 1));
              face.vertexTangents.push(cachedTangents[i33] ? cachedTangents[i33] : cachedTangents[i33] = new THREE.Vector4(tangents[i33], tangents[i33 + 1], tangents[i33 + 2], 1));
            }
            if (colors != null) {
              if (color_length === 3) {
                face.vertexColors.push(cachedColors[i13] ? cachedColors[i13] : cachedColors[i13] = new THREE.Color().setRGB(colors[i13], colors[i13 + 1], colors[i13 + 2]));
                face.vertexColors.push(cachedColors[i23] ? cachedColors[i23] : cachedColors[i23] = new THREE.Color().setRGB(colors[i23], colors[i23 + 1], colors[i23 + 2]));
                face.vertexColors.push(cachedColors[i33] ? cachedColors[i33] : cachedColors[i33] = new THREE.Color().setRGB(colors[i33], colors[i33 + 1], colors[i33 + 2]));
              }
              if (color_length === 4) {
                face.vertexColors.push(cachedColors[i14] ? cachedColors[i14] : cachedColors[i14] = new THREE.Color().setRGB(colors[i14], colors[i14 + 1], colors[i14 + 2]));
                face.vertexColors.push(cachedColors[i24] ? cachedColors[i24] : cachedColors[i24] = new THREE.Color().setRGB(colors[i24], colors[i24 + 1], colors[i24 + 2]));
                face.vertexColors.push(cachedColors[i34] ? cachedColors[i34] : cachedColors[i34] = new THREE.Color().setRGB(colors[i34], colors[i34 + 1], colors[i34 + 2]));
              }
            }
            geometry.faces.push(face);
          }
        }
        if (isSkinnedMesh) {
          geometry.computeCentroids();
          geometry.computeFaceNormals();
          try {
            geometry.computeTangents();
          } catch (e) {
            console.warn("error computing tangents");
          }
        }
        return geometry;
      };

      IFLLoader.prototype.convertBones = function(iflmesh) {
        var bind, bindingToJoint, bindings, bindpose, decomp, i, iflparent, invBindMatrix, jo, joint, jointMatrix, jointToBinding, jointToIndex, joints, p, parent, pos, root, rotq, scale, sk, skeletonJoint, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
        joints = [];
        jointToBinding = [];
        bindingToJoint = [];
        bindings = iflmesh.jointBindings;
        for (i = _i = 0, _ref = bindings.length; _i < _ref; i = _i += 1) {
          jo = this.library.getContent(bindings[i].jointID.id);
          if (!(jo != null)) {
            return null;
          }
          jointToBinding[jo._reference.id] = i;
          bindingToJoint[i] = jo._reference.id;
          joints.push(jo);
        }
        for (_j = 0, _len = joints.length; _j < _len; _j++) {
          joint = joints[_j];
          if (!this.library.findJointParent(joint)) {
            root = joint;
            break;
          }
        }
        bindpose = this.convertMatrix4(iflmesh.bindPoseMatrix);
        sk = [];
        sk.name = root.id;
        jointToIndex = [];
        skeletonJoint;

        for (i = _k = 0, _ref1 = bindings.length; _k < _ref1; i = _k += 1) {
          skeletonJoint = {};
          skeletonJoint.name = joints[i]._reference.id;
          jointMatrix = this.convertMatrix4(joints[i]._transformMatrix);
          invBindMatrix = this.convertMatrix4(bindings[i].inverseBindMatrix);
          decomp = jointMatrix.decompose();
          skeletonJoint.pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          skeletonJoint.rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          jointToIndex[skeletonJoint.name] = sk.length;
          skeletonJoint.invBindMatrix = invBindMatrix;
          skeletonJoint.jointMatrix = jointMatrix;
          sk.push(skeletonJoint);
        }
        for (i = _l = 0, _ref2 = bindings.length; _l < _ref2; i = _l += 1) {
          skeletonJoint = sk[i];
          parent = this.library.findJointParent(joints[i]);
          if (!(parent != null)) {
            skeletonJoint.parent = -1;
          } else {
            if (parent.iflType === "IFLJoint") {
              if (jointToIndex[parent._reference.id] !== void 0) {
                skeletonJoint.parent = jointToIndex[parent._reference.id];
              } else {
                skeletonJoint.parent = -1;
              }
            } else {
              skeletonJoint.parent = -1;
            }
          }
        }
        for (i = _m = 0, _ref3 = bindings.length; _m < _ref3; i = _m += 1) {
          skeletonJoint = sk[i];
          bind = skeletonJoint.invBindMatrix.clone();
          scale = this.setScale1(bind);
          bind.getInverse(bind);
          if (i !== 0) {
            p = sk[skeletonJoint.parent];
            bind.multiply(p.invBindMatrix, bind);
            iflparent = this.library.findParent(this.library.getContent(skeletonJoint.name));
            if (iflparent.iflType !== "IFLJoint") {
              this.prependNonJointParents(bind, iflparent);
            }
          } else {
            bind.multiply(bindpose, bind);
          }
          decomp = bind.decompose();
          pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          skeletonJoint.pos = pos;
          skeletonJoint.rotq = rotq;
        }
        return sk;
      };

      IFLLoader.prototype.prependNonJointParents = function(bind, iflparent) {
        var otherparent, parentmat, prepended;
        parentmat = this.convertMatrix4(iflparent._transformMatrix);
        prepended = new THREE.Matrix4().multiply(parentmat, bind);
        bind.copy(prepended);
        otherparent = this.library.findParent(iflparent);
        if (otherparent.iflType !== "IFLJoint") {
          return this.prependNonJointParents(bind, otherparent);
        }
      };

      IFLLoader.prototype.setScale1 = function(m) {
        var x, y, z;
        x = new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).length();
        y = new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).length();
        z = new THREE.Vector3(m.elements[8], m.elements[9], m.elements[10]).length();
        m.elements[0] /= x;
        m.elements[1] /= x;
        m.elements[2] /= x;
        m.elements[4] /= y;
        m.elements[5] /= y;
        m.elements[6] /= y;
        m.elements[8] /= z;
        m.elements[9] /= z;
        m.elements[10] /= z;
        m.elements[12] /= x;
        m.elements[13] /= y;
        m.elements[14] /= z;
        m.elements[15] = 1;
        return new THREE.Vector3(x, y, z);
      };

      IFLLoader.prototype.findJointParent = function(joint, root) {
        var childID, p, _i, _len, _ref;
        if (!(root != null)) {
          return null;
        }
        _ref = root.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          if (childID.id === joint._reference.id) {
            return root;
          } else {
            p = findJointParent(joint, this.library.getContent(childID.id));
            if (p) {
              return p;
            }
          }
        }
        return null;
      };

      IFLLoader.prototype.convertAnimations = function(skeleton, iflMesh) {
        var anim, anim3js, anims, bindpose, firstKey, i, j, k, key3js, keys, lastkey, maxTime, numTimes, r, sampler, stillMatDec, stillPos, stillRot, timePerFrame, totalMaxTime, track, track3js, trackLength, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
        anims = this.library.getAnimationsForSkinJoints(iflMesh);
        r = [];
        bindpose = this.convertMatrix4(iflMesh.bindPoseMatrix);
        if (anims.length === 0) {
          anims[0] = {
            _reference: {
              id: "fake"
            },
            tracks: []
          };
        }
        for (i = _i = 0; _i < 1; i = _i += 1) {
          anim3js = {};
          anim3js.name = iflMesh._reference.id + "_" + anims[i]._reference.id;
          anim3js.fps = 30;
          anim3js.hierarchy = [];
          totalMaxTime = 0;
          for (k = _j = 0, _ref = skeleton.length; _j < _ref; k = _j += 1) {
            track = this.getTrackForJoint(skeleton[k], anims[i]);
            stillMatDec = skeleton[k].jointMatrix.decompose();
            maxTime = 0;
            stillPos = skeleton[k].pos;
            stillRot = skeleton[k].rotq;
            if (track != null) {
              track3js = {};
              track3js.parent = skeleton[k].parent;
              track3js.name = "track_" + skeleton[k].name;
              track3js.keys = [];
              sampler = track.sampler;
              trackLength = track.end - track.start;
              numTimes = sampler.times.length;
              timePerFrame = (trackLength / numTimes) * 1000;
              for (j = _k = 0, _ref1 = sampler.times.length; _k < _ref1; j = _k += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [sampler.positions[j].x, sampler.positions[j].y, sampler.positions[j].z];
                key3js.rot = [sampler.orientations[j].x, sampler.orientations[j].y, sampler.orientations[j].z, sampler.orientations[j].w];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            } else {
              console.log("no track for joint " + skeleton[k].name + " creating a fake one");
              anim = anims[i];
              sampler = anim.tracks.length > 0 ? anim.tracks[0].sampler : {
                times: [0, 1]
              };
              track3js = {};
              track3js.name = "fake_track_" + skeleton[k].name;
              track3js.parent = skeleton[k].parent;
              track3js.keys = [];
              for (j = _l = 0, _ref2 = sampler.times.length; _l < _ref2; j = _l += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [stillPos[0], stillPos[1], stillPos[2]];
                key3js.rot = [stillRot[0], stillRot[1], stillRot[2], stillRot[3]];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            }
            anim3js.length = maxTime;
            anim3js.hierarchy.push(track3js);
          }
          for (k = _m = 0, _ref3 = anim3js.hierarchy.length; _m < _ref3; k = _m += 1) {
            keys = anim3js.hierarchy[k].keys;
            lastkey = keys[keys.length - 1];
            firstKey = keys[0];
            if (lastkey.time < totalMaxTime) {
              keys.push({
                time: totalMaxTime,
                pos: lastkey.pos,
                rot: lastkey.rot,
                scl: lastkey.scl
              });
            }
            if (firstKey.time > 0) {
              keys.unshift({
                time: 0,
                pos: firstKey.pos,
                rot: firstKey.rot,
                scl: firstKey.scl
              });
            }
          }
          anim3js.length = totalMaxTime;
          r.push(anim3js);
        }
        return r[0];
      };

      IFLLoader.prototype.getTrackForJoint = function(joint, anim) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = anim.tracks.length; _i < _ref; i = _i += 1) {
          if (anim.tracks[i].target.id === joint.name) {
            return anim.tracks[i];
          }
        }
        return null;
      };

      IFLLoader.prototype.convertMaterial = function(subMesh) {
        var matid, params;
        matid = subMesh.material._reference.id;
        if (!this.matCache[matid]) {
          params = {
            color: subMesh.material.diffuse.uintValue,
            ambient: subMesh.material.ambient.uintValue,
            specular: subMesh.material.specular.uintValue,
            map: this.getSubmeshTexture(subMesh.diffuseTextures),
            normalMap: this.getSubmeshTexture(subMesh.normalTextures),
            specularMap: this.getSubmeshTexture(subMesh.specularTextures),
            lightMap: null,
            bumpMap: null,
            reflectivity: subMesh.material.reflectivity,
            opacity: subMesh.material.transparency !== 0 && subMesh.material.transparency !== 1 ? 1 - subMesh.material.transparency : 1,
            wireframe: false,
            side: THREE.DoubleSide,
            transparent: false
          };
          this.matCache[matid] = new THREE.MeshPhongMaterial(params);
        }
        return this.matCache[matid];
      };

      IFLLoader.prototype.getSubmeshTexture = function(from) {
        if (from.length > 0) {
          return this.getTexture(from[0].id, false);
        }
        return null;
      };

      IFLLoader.prototype.getTexture = function(id) {
        var ret, tex;
        tex = this.library.getContent(id);
        if ((tex != null ? tex.converted : void 0) != null) {
          if (!(this.texCache[tex._reference.id] != null)) {
            this.texCache[tex._reference.id] = ret = new THREE.DataTexture(tex.converted, tex._width, tex._height, tex._hasOriginalByteArray ? THREE.RGBFormat : THREE.RGBAFormat);
          } else {
            ret = this.texCache[tex._reference.id];
          }
        }
        if (ret != null) {
          ret.needsUpdate = true;
        }
        if (ret != null) {
          ret.flipY = false;
        }
        return ret;
      };

      IFLLoader.prototype.getCubeTexture = function(array) {
        var image, images, index, path, tex, texture, _i, _len;
        images = [];
        texture = new THREE.Texture();
        texture.image = images;
        texture.flipY = false;
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          path = array[index];
          tex = this.getTexture(path);
          image = tex.image;
          image.format = tex.format;
          images[index] = image;
        }
        texture.needsUpdate = true;
        return texture;
      };

      IFLLoader.prototype.IFLLibraryFuncs = {
        getContent: function(id) {
          return this._contentByID[id];
        },
        getRootNodes: function() {
          return this.getRootNodesIn(this._content);
        },
        isIFLNode: function(object) {
          return object.iflType === "IFLNode" || object.iflType === "IFLJoint" || object.iflType === "IFLMesh" || object.iflType === "IFLMeshContainer" || object.iflType === "IFLLight" || object.iflType === "IFLCamera";
        },
        getDiffuseTexture: function(subMesh) {
          return this.getContent(subMesh._diffuseTextures[0].id);
        },
        getRootNodesIn: function(lib) {
          var k, m, meshesChildrenOfSomeone, meshesNotChildrenOfSomeone, tm, _i, _j, _len, _len1, _ref;
          meshesChildrenOfSomeone = [];
          meshesNotChildrenOfSomeone = [];
          for (_i = 0, _len = lib.length; _i < _len; _i++) {
            tm = lib[_i];
            if (!(this.isIFLNode(tm))) {
              continue;
            }
            if (meshesChildrenOfSomeone.indexOf(tm._reference.id) === -1) {
              meshesNotChildrenOfSomeone.push(tm._reference.id);
            }
            _ref = tm.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              m = _ref[_j];
              if (meshesNotChildrenOfSomeone.indexOf(m.id) !== -1) {
                meshesNotChildrenOfSomeone.splice(meshesNotChildrenOfSomeone.indexOf(m.id), 1);
              }
              meshesChildrenOfSomeone.push(m.id);
            }
          }
          return (function() {
            var _k, _ref1, _results;
            _results = [];
            for (k = _k = 0, _ref1 = meshesNotChildrenOfSomeone.length; _k < _ref1; k = _k += 1) {
              _results.push(this.getContent(meshesNotChildrenOfSomeone[k]));
            }
            return _results;
          }).call(this);
        },
        isRoot: function(contentID) {
          return this.isRootWithin(contentID, this._content);
        },
        isRootWithin: function(contentID, context) {
          var childID, content, _i, _j, _len, _len1, _ref;
          for (_i = 0, _len = context.length; _i < _len; _i++) {
            content = context[_i];
            if (this.isIFLNode(content)) {
              _ref = content.childIDs;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                childID = _ref[_j];
                if (childID.id === contentID) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        findParent: function(node, parent) {
          var ch, childID, p, rootNode, rootNodes, _i, _j, _len, _len1, _ref;
          if (!(parent != null)) {
            rootNodes = this.getRootNodes();
            for (_i = 0, _len = rootNodes.length; _i < _len; _i++) {
              rootNode = rootNodes[_i];
              p = this.findParent(node, rootNode);
              if (p != null) {
                return p;
              }
            }
          } else {
            _ref = parent.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              childID = _ref[_j];
              if (childID.id === node._reference.id) {
                return parent;
              } else {
                ch = this.getContent(childID.id);
                if (ch) {
                  p = this.findParent(node, ch);
                  if (p != null) {
                    return p;
                  }
                }
              }
            }
          }
          return null;
        },
        getAnimationsForSkinJoints: function(skin) {
          var animRet, doneAnims, jobj, joint, jointAnimation, jointAnimations, r, track, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
          r = [];
          doneAnims = [];
          _ref = skin.jointBindings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            jobj = _ref[_i];
            joint = jobj.jointID;
            jointAnimations = this.getAnimationsForID(joint.id, false);
            if ((jointAnimations != null)) {
              for (_j = 0, _len1 = jointAnimations.length; _j < _len1; _j++) {
                jointAnimation = jointAnimations[_j];
                if (!doneAnims[jointAnimation._reference.id]) {
                  doneAnims[jointAnimation._reference.id] = {
                    tracks: [],
                    iflType: "IFLAnimation"
                  };
                  doneAnims[jointAnimation._reference.id]._reference = {
                    id: jointAnimation._reference.id,
                    iflType: "IFLID"
                  };
                  r.push(doneAnims[jointAnimation._reference.id]);
                }
                animRet = doneAnims[jointAnimation._reference.id];
                _ref1 = jointAnimation.tracks;
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  track = _ref1[_k];
                  if (animRet.tracks.indexOf(track) === -1) {
                    animRet.tracks.push(track);
                  }
                }
              }
            }
          }
          return r;
        },
        getAnimationsForID: function(id) {
          var animation, r, track, tracks, _i, _j, _len, _len1, _ref;
          r = [];
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            animation = _ref[_i];
            if (!(animation.iflType === "IFLAnimation")) {
              continue;
            }
            tracks = animation.tracks;
            for (_j = 0, _len1 = tracks.length; _j < _len1; _j++) {
              track = tracks[_j];
              if (track.target.id === id && r.indexOf(animation) === -1) {
                r.push(animation);
              }
            }
          }
          if (r.length > 0) {
            return r;
          }
          return null;
        },
        findJointParent: function(node) {
          var childID, content, _i, _j, _len, _len1, _ref, _ref1;
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            content = _ref[_i];
            if (this.isIFLNode(content)) {
              _ref1 = content.childIDs;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                childID = _ref1[_j];
                if (childID.id === node._reference.id) {
                  if (content.iflType === "IFLJoint") {
                    return content;
                  } else {
                    return this.findJointParent(content);
                  }
                }
              }
            }
          }
          return null;
        }
      };

      return IFLLoader;

    })()
  });

  App = (function() {
    var clock;

    App.prototype.container = null;

    App.prototype.stats = null;

    App.prototype.camera = null;

    App.prototype.scene = null;

    App.prototype.projector = null;

    App.prototype.renderer = null;

    App.prototype.controls = null;

    App.prototype.mesh = null;

    clock = new THREE.Clock();

    function App() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.onModelLoaded = __bind(this.onModelLoaded, this);

      this.onModelProgress = __bind(this.onModelProgress, this);

      var radius;
      this.container = document.createElement('div');
      document.body.appendChild(this.container);
      this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
      this.camera.position.z = 500;
      this.camera.target = new THREE.Vector3(0, 0, 0);
      this.scene = new THREE.Scene();
      this.light = new THREE.DirectionalLight(0xefefff, 2);
      this.light.position.set(1, 1, 1).normalize();
      this.scene.add(this.light);
      this.light = new THREE.DirectionalLight(0xffefef, 2);
      this.light.position.set(-1, -1, -1).normalize();
      this.scene.add(this.light);
      this.loader = new ifl.IFLLoader();
      this.loader.load("models/boy.if3d", this.onModelLoaded, this.onModelProgress);
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.sortObjects = false;
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.container.appendChild(this.renderer.domElement);
      radius = this.camera.position.z;
      this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
      this.controls.rotateSpeed = 1.0;
      this.controls.zoomSpeed = 1.2;
      this.controls.panSpeed = 0.2;
      this.controls.noZoom = false;
      this.controls.noPan = false;
      this.controls.staticMoving = false;
      this.controls.dynamicDampingFactor = 0.3;
      this.controls.minDistance = radius / 2;
      this.controls.maxDistance = radius * 100;
      this.controls.keys = [65, 83, 68];
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      this.container.appendChild(this.stats.domElement);
      window.addEventListener('resize', this.onWindowResize, false);
      this.animate();
    }

    App.prototype.totalModels = 3;

    App.prototype.modelsLoaded = 0;

    App.prototype.onModelProgress = function(data) {};

    App.prototype.onModelLoaded = function(iflscene) {
      var animation, mesh, _i, _len, _ref, _ref1;
      this.modelsLoaded++;
      this.scene.add(iflscene);
      _ref = iflscene.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mesh = _ref[_i];
        if (!(((_ref1 = mesh.geometry) != null ? _ref1.animation : void 0) != null)) {
          continue;
        }
        THREE.AnimationHandler.add(mesh.geometry.animation);
        animation = new THREE.Animation(mesh, mesh.geometry.animation.name);
        animation.JITCompile = false;
        animation.interpolationType = THREE.AnimationHandler.LINEAR;
        animation.play();
      }
      return null;
    };

    App.prototype.animate = function() {
      window.requestAnimationFrame(this.animate);
      this.render();
      this.stats.update();
      return null;
    };

    App.prototype.render = function() {
      var delta;
      delta = clock.getDelta();
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
      THREE.AnimationHandler.update(delta);
      return null;
    };

    App.prototype.onWindowResize = function() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.controls.handleResize();
      return null;
    };

    return App;

  })();

  if (!Detector.webgl || !Detector.workers) {
    Detector.addGetWebGLMessage();
  } else {
    new App();
  }

}).call(this);
