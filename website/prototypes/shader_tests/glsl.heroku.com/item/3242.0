{"code":" // Some hills...\n// rotwang: @mod* lowered cam for better flight feeling\n// @mod+ mouse y controls flight height\n// @mod* some color tests\n// @mod+ Canyon\n// @emackey: Simple sky blue (no clouds...)\n// @rotwang: mod* sky gradient, different terrain front and backcolor\n// @mod* stripes texture\n// @mod* terrain variation\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n//Simple raymarching sandbox with camera\n\n//Raymarching Distance Fields\n//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n//Also known as Sphere Tracing\n//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024\n\n//Util Start\n\nmat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat fbm_5oct( vec2 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat fbm_3oct( vec2 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n\n    return f/1.5;\n}\n\nvec2 ObjUnion(in vec2 obj_floor,in vec2 obj_roundBox){\n  if (obj_floor.x<obj_roundBox.x)\n  \treturn obj_floor;\n  else\n  \treturn obj_roundBox;\n}\n//Util End\n\n//Scene Start\n\n//Torus\nfloat torus(in vec3 p, in vec2 t){\n\tvec2 q = vec2(length(vec2(p.x,p.z))-t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n//Sphere\nfloat sphere(in vec3 p, float radius){\n\tfloat length = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n\treturn length-radius;\n}\n\n\nvec2 terrain(in vec3 p){\n\t\n\n\tfloat da = sin(0.9*p.y)*fbm_3oct(p.xz); \n  \tvec2 vd = vec2(p.y+fbm_3oct(p.xz / 9.0) * 9.33 ,0);\n\tvd.x += da;\n \t\n\treturn vd;\n}\n\nvec3 hsv2rgb(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n/**\n@rotwang:\nsmoothes between 2 vectors a and b (eg colors)\nusing a source value and a smooth amount\nabout the base as center.\n*/\nvec3 smoothmix(vec3 a, vec3 b, float base, float smooth, float source)\n{\n\tfloat f = smoothstep(base-smooth, base+smooth, source );\n\tvec3 vec = mix(a, b, f);\n\treturn vec;\n}\n\n\n//Terrain Color \nvec3 terrain_clr(in vec3 p){\n\t\n\t\n\tvec3 clr_a = vec3(0.4, 0.5, 0.2);\n\tvec3 clr_b = vec3(0.3, 0.3, 0.3);\n\tfloat m = fract(p.y*4.0);\n\tfloat g = fbm_3oct(p.xz * 28.0);\n\tclr_b += g;\n\tvec3 clr =  smoothmix(clr_a, clr_b,0.76, 0.3, m );\n\tclr = mix( clr, g*clr, 0.6);\n\n\t\n \treturn clr; \n}\n\n//IQs RoundBox (try other objects http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nvec2 obj_roundBox(in vec3 p){\n  return vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\nvec2 obj_sphere(in vec3 p){\n  return vec2(length(p)-2.0);\n}\n\n//RoundBox with simple solid color\nvec3 obj_roundBox_c(in vec3 p){\n\treturn vec3(1.0,0.5,0.2);\n}\n\n//Objects union\nvec2 inObj(in vec3 p){\n  return terrain(p);\n}\n\n//Scene End\n\nvoid main(void){\n  //Camera animation\n  vec3 U=vec3(0,1,0);//Camera Up Vector\n\n\tfloat speed = time*2.0;\n\tfloat my =  sin(time/8.0); // mouse.y*4.0;\n\tfloat camy = -1.0+my; \n\tfloat tary = -1.0+my; \n  vec3 E=vec3(speed, camy, 0);//vec3(-sin(time/4.0)*8.0,4,cos(time/4.0)*8.0); //Camera location; Change camera path position here\n  vec3 viewDir=vec3(E.x-sin(mouse.x*0.0),tary,E.z+cos(mouse.x*0.0)); //Change camere view vector here\n  //vec3 E=vec3(mouse.x*0.0, 4, mouse.y*4.0); //Camera location; Change camera path position here\n\t\n  //Camera setup\n  vec3 C=normalize(viewDir-E);\n  vec3 A=cross(C, U);\n  vec3 B=cross(A, C);\n  vec3 M=(E+C);\n  \n  vec2 vPos=2.0*gl_FragCoord.xy/resolution.xy - 1.0; // (2*Sx-1) where Sx = x in screen space (between 0 and 1)\n  vec3 scrCoord=M + vPos.x*A*resolution.x/resolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)\n  vec3 scp=normalize(scrCoord-E);\n\n  //Raymarching\n  const vec3 e=vec3(0.1,0,0);\n  const float MAX_DEPTH=60.0; //Max depth\n\n  vec2 s=vec2(0.1,0.0);\n  vec3 c,p,n;\n\n  float f=1.0;\n  for(int i=0;i<100;i++){\n    if (abs(s.x)<.01||f>MAX_DEPTH) break;\n    f+=s.x;\n    p=E+scp*f;\n    s=inObj(p);\n  }\n  \n  if (f<MAX_DEPTH){\n    if (s.y==0.0)\n      c=terrain_clr(p);\nvec3 cc = vec3(0.7, c.g, c.b);\n\t \n\tfloat m = smoothstep(3.0, 20.0, f);\n\t c = mix(c,cc, 1.0-m);\n\n\t  \n    n=normalize(\n      vec3(s.x-inObj(p-e.xyy).x,\n           s.x-inObj(p-e.yxy).x,\n           s.x-inObj(p-e.yyx).x));\n    float b=dot(n,normalize(E-p));\n\t  \n    gl_FragColor=vec4(b*c*(2.0-f*.01),1.0);//simple phong LightPosition=CameraPosition\n  }\n\telse {\n\t\tfloat invy = 1.0-vPos.y;\n\t\tfloat r = invy*0.8;\n\t\tfloat g = 0.2 + invy*0.7;\n\t\tvec3 sky_clr = vec3(r,g,0.9);\n\t\tgl_FragColor=vec4( sky_clr,1.0); //background color\n\t}\n\t\n}","user":"f2b2e4a","parent":"/e#3212.0"}