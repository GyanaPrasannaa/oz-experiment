// Generated by CoffeeScript 1.3.3
(function() {
  var App, IFLLoader, MaterialManager, namespace,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  namespace = function(name, values) {
    var key, subpackage, target, value, _i, _len, _ref;
    if (this.hasOwnProperty("window")) {
      target = window;
    } else if (this.hasOwnProperty("exports")) {
      target = exports;
    } else {
      target = this;
    }
    if (name.length > 0) {
      _ref = name.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subpackage = _ref[_i];
        target = target[subpackage] || (target[subpackage] = {});
      }
    }
    for (key in values) {
      value = values[key];
      target[key] = value;
    }
    return target;
  };

  namespace('', {
    namespace: namespace
  });

  namespace("ifl", {
    IFLVertexAttribute: {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    }
  });

  namespace("ifl", {
    IFLLoader: IFLLoader = (function() {

      IFLLoader.prototype.library = null;

      IFLLoader.prototype.callback = null;

      IFLLoader.prototype.callbackProgress = null;

      IFLLoader.prototype.worker = null;

      IFLLoader.prototype.convertTextureIndex = 0;

      IFLLoader.prototype.texCache = null;

      IFLLoader.prototype.matCache = null;

      IFLLoader.prototype.t = 0;

      IFLLoader.prototype.url = null;

      IFLLoader.prototype.loadingPhase = 0;

      IFLLoader.prototype.totalLoadingPhases = 4;

      function IFLLoader() {
        this.onXHRReadyStatusChange = __bind(this.onXHRReadyStatusChange, this);

        this.onXHRProgress = __bind(this.onXHRProgress, this);

        this.onWorkerMessage = __bind(this.onWorkerMessage, this);
        this.worker = new Worker('js/libs/workers.js');
        this.worker.onmessage = this.onWorkerMessage;
        this.texCache = {};
        this.matCache = {};
      }

      IFLLoader.prototype.onWorkerMessage = function(event) {
        var loaded, subtype, total;
        switch (event.data.type) {
          case "console":
            return console[event.data.action](event.data.msg);
          case "progress":
            loaded = event.data.data.progress;
            total = event.data.data.total;
            subtype = event.data.subtype;
            return this.handleProgress(loaded, total);
          default:
            return this[event.data.callback](event.data.data);
        }
      };

      IFLLoader.prototype.handleProgress = function(loaded, total) {
        var currentUnitBase, currentUnitProgress, totalLoaded, unit;
        if (this.callbackProgress != null) {
          unit = 100 / this.totalLoadingPhases;
          currentUnitBase = unit * this.loadingPhase;
          currentUnitProgress = (loaded * unit) / total;
          totalLoaded = currentUnitBase + currentUnitProgress;
          this.callbackProgress(totalLoaded, 100);
          return console.log("TotalLoaded:" + totalLoaded + ", Phase: " + this.loadingPhase + ", loaded:" + loaded + ", total:" + total);
        }
      };

      IFLLoader.prototype.load = function(url, callback, callbackProgress) {
        this.loadingPhase = 0;
        this.url = url;
        this.callback = callback;
        this.callbackProgress = callbackProgress;
        this.xhr = new XMLHttpRequest();
        this.xhr.onreadystatechange = this.onXHRReadyStatusChange;
        this.xhr.onprogress = this.onXHRProgress;
        this.xhr.open("GET", url, true);
        this.xhr.responseType = "arraybuffer";
        return this.xhr.send(null);
      };

      IFLLoader.prototype.onXHRProgress = function(event) {
        return this.handleProgress(event.loaded, event.total);
      };

      IFLLoader.prototype.onXHRReadyStatusChange = function() {
        var response, _ref;
        if (this.xhr.readyState === this.xhr.DONE) {
          if (this.xhr.status === 200 || this.xhr.status === 0) {
            response = (_ref = this.xhr.response) != null ? _ref : this.xhr.mozResponseArrayBuffer;
            this.decompressLibrary(response);
          } else {
            console.error("[ IFLLoader ]: Couldn't load [ " + url + " ] [ " + this.xhr.status + " ]");
          }
        }
      };

      IFLLoader.prototype.decompressLibrary = function(data) {
        this.t = new Date().getTime();
        this.loadingPhase++;
        return this.worker.postMessage({
          type: "inflate",
          data: data,
          callback: "parseLibrary"
        });
      };

      IFLLoader.prototype.parseLibrary = function(data) {
        console.log(("[" + this.url + "] decompression time: ") + (new Date().getTime() - this.t) / 1000);
        this.loadingPhase++;
        this.t = new Date().getTime();
        return this.worker.postMessage({
          type: "convert_library",
          data: data,
          callback: "onLibraryParsed"
        });
      };

      IFLLoader.prototype.onLibraryParsed = function(data) {
        var content, func, _i, _len, _ref;
        this.library = data;
        for (func in this.IFLLibraryFuncs) {
          this.library[func] = this.IFLLibraryFuncs[func];
        }
        this.library._contentByID = {};
        _ref = this.library._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          content = _ref[_i];
          this.library._contentByID[content._reference.id] = content;
        }
        console.log(("[" + this.url + "] library parse time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        this.loadingPhase++;
        return this.convertTextures();
      };

      IFLLoader.prototype.convertTextures = function() {
        var bmp, i, _i, _ref, _ref1;
        for (i = _i = _ref = this.convertTextureIndex, _ref1 = this.library._content.length; _i < _ref1; i = _i += 1) {
          if (this.library._content[i].iflType === "IFLBitmap") {
            bmp = this.library._content[i];
            this.convertTextureIndex = i + 1;
            if (bmp._hasOriginalByteArray) {
              this.worker.postMessage({
                type: "parse_jpg",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            } else {
              this.worker.postMessage({
                type: "convert_argb",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            }
            return;
          }
          this.handleProgress(i, this.library._content.length);
        }
        return this.createModel();
      };

      IFLLoader.prototype.onTextureConverted = function(data) {
        this.library._content[this.convertTextureIndex - 1].converted = data;
        return this.convertTextures();
      };

      IFLLoader.prototype.createModel = function() {
        var root, rootObject, rootObjects, _i, _len;
        console.log(("[" + this.url + "] convert textures time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        root = new THREE.Object3D();
        rootObjects = this.library.getRootNodes();
        for (_i = 0, _len = rootObjects.length; _i < _len; _i++) {
          rootObject = rootObjects[_i];
          root.add(this.convertNode(rootObject));
        }
        console.log(("[" + this.url + "] convert node time: ") + (new Date().getTime() - this.t) / 1000);
        this.callback(root);
        this.worker.postMessage({
          type: "kill"
        });
      };

      IFLLoader.prototype.convertNode = function(iflnode) {
        var child, childID, mat, retEntity, _i, _len, _ref;
        switch (iflnode.iflType) {
          case "IFLMesh":
            retEntity = this.convertMesh(iflnode);
            break;
          default:
            retEntity = new THREE.Object3D();
        }
        retEntity.name = iflnode._reference.id;
        retEntity.matrix = this.convertMatrix4(iflnode._transformMatrix);
        retEntity.scale.getScaleFromMatrix(retEntity.matrix);
        mat = new THREE.Matrix4().extractRotation(retEntity.matrix);
        retEntity.rotation.setEulerFromRotationMatrix(retEntity.matrix, retEntity.eulerOrder);
        retEntity.position.getPositionFromMatrix(retEntity.matrix);
        _ref = iflnode.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          child = this.library.getContent(childID.id);
          if (child) {
            retEntity.add(this.convertNode(child));
          }
        }
        return retEntity;
      };

      IFLLoader.prototype.convertMatrix4 = function(m) {
        return new THREE.Matrix4(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
      };

      IFLLoader.prototype.convertMesh = function(iflmesh) {
        var bone, color_length, colors, geometry, index, isSkinnedMesh, material, normals, positions, ret, skinIndices, skinWeights, tangents, uvs, _i, _len, _ref;
        positions = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.POSITION];
        uvs = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.UV];
        normals = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.NORMALS];
        tangents = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.TEX_TANGENTS];
        colors = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.COLOR];
        color_length = 0;
        if (colors != null) {
          color_length = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.COLOR];
        }
        skinWeights = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_WEIGHTS];
        skinIndices = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_INDICES];
        isSkinnedMesh = skinWeights && skinIndices;
        if (positions.length < 65535 && !isSkinnedMesh && iflmesh.subMeshes.length === 1) {
          geometry = this.convertBufferGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        } else {
          geometry = this.convertGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        }
        geometry.hasTangents = tangents != null;
        material = iflmesh.subMeshes.length === 1 ? geometry.materials[0] : new THREE.MeshFaceMaterial;
        material.skinning = isSkinnedMesh;
        if (isSkinnedMesh) {
          ret = new THREE.SkinnedMesh(geometry, material);
        } else {
          ret = new THREE.Mesh(geometry, material);
        }
        if (isSkinnedMesh) {
          _ref = ret.geometry.bones;
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            bone = _ref[index];
            ret.boneInverses[index] = bone.invBindMatrix;
          }
        }
        ret.castShadow = ret.receiveShadow = true;
        return ret;
      };

      IFLLoader.prototype.convertBufferGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var geometry, indexBuffer;
        geometry = new THREE.BufferGeometry;
        indexBuffer = iflmesh.subMeshes[0].indexBuffer._rawData;
        geometry.attributes = {};
        geometry.attributes.index = {
          itemSize: 1,
          array: new Int16Array(indexBuffer.length),
          numItems: indexBuffer.length
        };
        geometry.attributes.index.array.set(indexBuffer);
        geometry.attributes.position = {
          itemSize: 3,
          array: new Float32Array(positions.length),
          numItems: positions.length
        };
        geometry.attributes.position.array.set(positions);
        if (uvs) {
          geometry.attributes.uv = {
            itemSize: 2,
            array: new Float32Array(uvs.length),
            numItems: uvs.length
          };
          geometry.attributes.uv.array.set(uvs);
        }
        if (normals) {
          geometry.attributes.normal = {
            itemSize: 3,
            array: new Float32Array(normals.length),
            numItems: normals.length
          };
          geometry.attributes.normal.array.set(normals);
        }
        if (colors) {
          geometry.attributes.color = {
            itemSize: color_length,
            array: new Float32Array(colors.length),
            numItems: colors.length
          };
          geometry.attributes.color.array.set(colors);
        }
        if (tangents) {
          geometry.attributes.tangent = {
            itemSize: 3,
            array: new Float32Array(tangents.length),
            numItems: tangents.length
          };
          geometry.attributes.tangent.array.set(tangents);
        }
        geometry.offsets = [
          {
            start: 0,
            count: indexBuffer.length,
            index: 0
          }
        ];
        geometry.materials = [this.convertMaterial(iflmesh.subMeshes[0])];
        return geometry;
      };

      IFLLoader.prototype.convertGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var cachedColors, cachedNormals, cachedTangents, cachedUVs, face, faceIndex, fakeUV, fvUVs, geometry, i, i1, i12, i13, i14, i2, i22, i23, i24, i3, i32, i33, i34, ib, ibi, material, second, stepSize, subMesh, subMeshIndex, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _step;
        geometry = new THREE.Geometry;
        cachedUVs = [];
        cachedNormals = [];
        cachedTangents = [];
        cachedColors = [];
        if (positions) {
          for (i = _i = 0, _ref = positions.length; _i < _ref; i = _i += 3) {
            geometry.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
          }
        } else {
          return new THREE.Object3D();
        }
        if (isSkinnedMesh) {
          stepSize = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.JOINT_INDICES];
          if (stepSize <= 2) {
            for (i = _j = 0, _ref1 = skinIndices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += stepSize) {
              second = Math.floor(i + stepSize / 2);
              geometry.skinWeights.push(new THREE.Vector4(skinWeights[i], skinWeights[second], 0, 0));
              geometry.skinIndices.push(new THREE.Vector4(skinIndices[i], skinIndices[second], 0, 0));
            }
          }
          geometry.bones = this.convertBones(iflmesh);
          geometry.animation = this.convertAnimations(geometry.bones, iflmesh);
        }
        fakeUV = new THREE.UV(0, 0);
        _ref2 = iflmesh.subMeshes;
        for (subMeshIndex = _k = 0, _len = _ref2.length; _k < _len; subMeshIndex = ++_k) {
          subMesh = _ref2[subMeshIndex];
          material = this.convertMaterial(subMesh);
          material.skinning = isSkinnedMesh;
          geometry.materials.push(material);
          ib = subMesh.indexBuffer._rawData;
          for (ibi = _l = 0, _len1 = ib.length, _step = 3; _l < _len1; ibi = _l += _step) {
            i1 = ib[ibi];
            i2 = ib[ibi + 1];
            i3 = ib[ibi + 2];
            i12 = i1 * 2;
            i22 = i2 * 2;
            i32 = i3 * 2;
            i13 = i1 * 3;
            i23 = i2 * 3;
            i33 = i3 * 3;
            i14 = i1 * 4;
            i24 = i2 * 4;
            i34 = i3 * 4;
            face = new THREE.Face3(i1, i2, i3, null, null, subMeshIndex);
            faceIndex = geometry.faces.length;
            fvUVs = geometry.faceVertexUvs[0][faceIndex] = [];
            if (uvs != null) {
              fvUVs.push(cachedUVs[i12] ? cachedUVs[i12] : cachedUVs[i12] = new THREE.UV(uvs[i12], uvs[i12 + 1]));
              fvUVs.push(cachedUVs[i22] ? cachedUVs[i22] : cachedUVs[i22] = new THREE.UV(uvs[i22], uvs[i22 + 1]));
              fvUVs.push(cachedUVs[i32] ? cachedUVs[i32] : cachedUVs[i32] = new THREE.UV(uvs[i32], uvs[i32 + 1]));
            }
            if (normals != null) {
              face.vertexNormals.push(cachedNormals[i13] ? cachedNormals[i13] : cachedNormals[i13] = new THREE.Vector3(normals[i13], normals[i13 + 1], normals[i13 + 2]));
              face.vertexNormals.push(cachedNormals[i23] ? cachedNormals[i23] : cachedNormals[i23] = new THREE.Vector3(normals[i23], normals[i23 + 1], normals[i23 + 2]));
              face.vertexNormals.push(cachedNormals[i33] ? cachedNormals[i33] : cachedNormals[i33] = new THREE.Vector3(normals[i33], normals[i33 + 1], normals[i33 + 2]));
            }
            if (tangents != null) {
              face.vertexTangents.push(cachedTangents[i13] ? cachedTangents[i13] : cachedTangents[i13] = new THREE.Vector4(tangents[i13], tangents[i13 + 1], tangents[i13 + 2], 1));
              face.vertexTangents.push(cachedTangents[i23] ? cachedTangents[i23] : cachedTangents[i23] = new THREE.Vector4(tangents[i23], tangents[i23 + 1], tangents[i23 + 2], 1));
              face.vertexTangents.push(cachedTangents[i33] ? cachedTangents[i33] : cachedTangents[i33] = new THREE.Vector4(tangents[i33], tangents[i33 + 1], tangents[i33 + 2], 1));
            }
            if (colors != null) {
              if (color_length === 3) {
                face.vertexColors.push(cachedColors[i13] ? cachedColors[i13] : cachedColors[i13] = new THREE.Color().setRGB(colors[i13], colors[i13 + 1], colors[i13 + 2]));
                face.vertexColors.push(cachedColors[i23] ? cachedColors[i23] : cachedColors[i23] = new THREE.Color().setRGB(colors[i23], colors[i23 + 1], colors[i23 + 2]));
                face.vertexColors.push(cachedColors[i33] ? cachedColors[i33] : cachedColors[i33] = new THREE.Color().setRGB(colors[i33], colors[i33 + 1], colors[i33 + 2]));
              }
              if (color_length === 4) {
                face.vertexColors.push(cachedColors[i14] ? cachedColors[i14] : cachedColors[i14] = new THREE.Color().setRGB(colors[i14], colors[i14 + 1], colors[i14 + 2]));
                face.vertexColors.push(cachedColors[i24] ? cachedColors[i24] : cachedColors[i24] = new THREE.Color().setRGB(colors[i24], colors[i24 + 1], colors[i24 + 2]));
                face.vertexColors.push(cachedColors[i34] ? cachedColors[i34] : cachedColors[i34] = new THREE.Color().setRGB(colors[i34], colors[i34 + 1], colors[i34 + 2]));
              }
            }
            geometry.faces.push(face);
          }
        }
        if (isSkinnedMesh) {
          geometry.computeCentroids();
          geometry.computeFaceNormals();
          try {
            geometry.computeTangents();
          } catch (e) {
            console.warn("error computing tangents");
          }
        }
        return geometry;
      };

      IFLLoader.prototype.convertBones = function(iflmesh) {
        var bind, bindingToJoint, bindings, bindpose, decomp, i, iflparent, invBindMatrix, jo, joint, jointMatrix, jointToBinding, jointToIndex, joints, p, parent, pos, root, rotq, scale, sk, skeletonJoint, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
        joints = [];
        jointToBinding = [];
        bindingToJoint = [];
        bindings = iflmesh.jointBindings;
        for (i = _i = 0, _ref = bindings.length; _i < _ref; i = _i += 1) {
          jo = this.library.getContent(bindings[i].jointID.id);
          if (!(jo != null)) {
            return null;
          }
          jointToBinding[jo._reference.id] = i;
          bindingToJoint[i] = jo._reference.id;
          joints.push(jo);
        }
        for (_j = 0, _len = joints.length; _j < _len; _j++) {
          joint = joints[_j];
          if (!this.library.findJointParent(joint)) {
            root = joint;
            break;
          }
        }
        bindpose = this.convertMatrix4(iflmesh.bindPoseMatrix);
        sk = [];
        sk.name = root.id;
        jointToIndex = [];
        skeletonJoint;

        for (i = _k = 0, _ref1 = bindings.length; _k < _ref1; i = _k += 1) {
          skeletonJoint = {};
          skeletonJoint.name = joints[i]._reference.id;
          jointMatrix = this.convertMatrix4(joints[i]._transformMatrix);
          invBindMatrix = this.convertMatrix4(bindings[i].inverseBindMatrix);
          decomp = jointMatrix.decompose();
          skeletonJoint.pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          skeletonJoint.rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          jointToIndex[skeletonJoint.name] = sk.length;
          skeletonJoint.invBindMatrix = invBindMatrix;
          skeletonJoint.jointMatrix = jointMatrix;
          sk.push(skeletonJoint);
        }
        for (i = _l = 0, _ref2 = bindings.length; _l < _ref2; i = _l += 1) {
          skeletonJoint = sk[i];
          parent = this.library.findJointParent(joints[i]);
          if (!(parent != null)) {
            skeletonJoint.parent = -1;
          } else {
            if (parent.iflType === "IFLJoint") {
              if (jointToIndex[parent._reference.id] !== void 0) {
                skeletonJoint.parent = jointToIndex[parent._reference.id];
              } else {
                skeletonJoint.parent = -1;
              }
            } else {
              skeletonJoint.parent = -1;
            }
          }
        }
        for (i = _m = 0, _ref3 = bindings.length; _m < _ref3; i = _m += 1) {
          skeletonJoint = sk[i];
          bind = skeletonJoint.invBindMatrix.clone();
          scale = this.setScale1(bind);
          bind.getInverse(bind);
          if (i !== 0) {
            p = sk[skeletonJoint.parent];
            bind.multiply(p.invBindMatrix, bind);
            iflparent = this.library.findParent(this.library.getContent(skeletonJoint.name));
            if (iflparent.iflType !== "IFLJoint") {
              this.prependNonJointParents(bind, iflparent);
            }
          } else {
            bind.multiply(bindpose, bind);
          }
          decomp = bind.decompose();
          pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          skeletonJoint.pos = pos;
          skeletonJoint.rotq = rotq;
        }
        return sk;
      };

      IFLLoader.prototype.prependNonJointParents = function(bind, iflparent) {
        var otherparent, parentmat, prepended;
        parentmat = this.convertMatrix4(iflparent._transformMatrix);
        prepended = new THREE.Matrix4().multiply(parentmat, bind);
        bind.copy(prepended);
        otherparent = this.library.findParent(iflparent);
        if (otherparent.iflType !== "IFLJoint") {
          return this.prependNonJointParents(bind, otherparent);
        }
      };

      IFLLoader.prototype.setScale1 = function(m) {
        var x, y, z;
        x = new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).length();
        y = new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).length();
        z = new THREE.Vector3(m.elements[8], m.elements[9], m.elements[10]).length();
        m.elements[0] /= x;
        m.elements[1] /= x;
        m.elements[2] /= x;
        m.elements[4] /= y;
        m.elements[5] /= y;
        m.elements[6] /= y;
        m.elements[8] /= z;
        m.elements[9] /= z;
        m.elements[10] /= z;
        m.elements[12] /= x;
        m.elements[13] /= y;
        m.elements[14] /= z;
        m.elements[15] = 1;
        return new THREE.Vector3(x, y, z);
      };

      IFLLoader.prototype.findJointParent = function(joint, root) {
        var childID, p, _i, _len, _ref;
        if (!(root != null)) {
          return null;
        }
        _ref = root.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          if (childID.id === joint._reference.id) {
            return root;
          } else {
            p = findJointParent(joint, this.library.getContent(childID.id));
            if (p) {
              return p;
            }
          }
        }
        return null;
      };

      IFLLoader.prototype.convertAnimations = function(skeleton, iflMesh) {
        var anim, anim3js, anims, bindpose, firstKey, i, j, k, key3js, keys, lastkey, maxTime, numTimes, r, sampler, stillMatDec, stillPos, stillRot, timePerFrame, totalMaxTime, track, track3js, trackLength, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
        anims = this.library.getAnimationsForSkinJoints(iflMesh);
        r = [];
        bindpose = this.convertMatrix4(iflMesh.bindPoseMatrix);
        if (anims.length === 0) {
          anims[0] = {
            _reference: {
              id: "fake"
            },
            tracks: []
          };
        }
        for (i = _i = 0; _i < 1; i = _i += 1) {
          anim3js = {};
          anim3js.name = iflMesh._reference.id + "_" + anims[i]._reference.id;
          anim3js.fps = 30;
          anim3js.hierarchy = [];
          totalMaxTime = 0;
          for (k = _j = 0, _ref = skeleton.length; _j < _ref; k = _j += 1) {
            track = this.getTrackForJoint(skeleton[k], anims[i]);
            stillMatDec = skeleton[k].jointMatrix.decompose();
            maxTime = 0;
            stillPos = skeleton[k].pos;
            stillRot = skeleton[k].rotq;
            if (track != null) {
              track3js = {};
              track3js.parent = skeleton[k].parent;
              track3js.name = "track_" + skeleton[k].name;
              track3js.keys = [];
              sampler = track.sampler;
              trackLength = track.end - track.start;
              numTimes = sampler.times.length;
              timePerFrame = (trackLength / numTimes) * 1000;
              for (j = _k = 0, _ref1 = sampler.times.length; _k < _ref1; j = _k += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [sampler.positions[j].x, sampler.positions[j].y, sampler.positions[j].z];
                key3js.rot = [sampler.orientations[j].x, sampler.orientations[j].y, sampler.orientations[j].z, sampler.orientations[j].w];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            } else {
              console.log("no track for joint " + skeleton[k].name + " creating a fake one");
              anim = anims[i];
              sampler = anim.tracks.length > 0 ? anim.tracks[0].sampler : {
                times: [0, 1]
              };
              track3js = {};
              track3js.name = "fake_track_" + skeleton[k].name;
              track3js.parent = skeleton[k].parent;
              track3js.keys = [];
              for (j = _l = 0, _ref2 = sampler.times.length; _l < _ref2; j = _l += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [stillPos[0], stillPos[1], stillPos[2]];
                key3js.rot = [stillRot[0], stillRot[1], stillRot[2], stillRot[3]];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            }
            anim3js.length = maxTime;
            anim3js.hierarchy.push(track3js);
          }
          for (k = _m = 0, _ref3 = anim3js.hierarchy.length; _m < _ref3; k = _m += 1) {
            keys = anim3js.hierarchy[k].keys;
            lastkey = keys[keys.length - 1];
            firstKey = keys[0];
            if (lastkey.time < totalMaxTime) {
              keys.push({
                time: totalMaxTime,
                pos: lastkey.pos,
                rot: lastkey.rot,
                scl: lastkey.scl
              });
            }
            if (firstKey.time > 0) {
              keys.unshift({
                time: 0,
                pos: firstKey.pos,
                rot: firstKey.rot,
                scl: firstKey.scl
              });
            }
          }
          anim3js.length = totalMaxTime;
          r.push(anim3js);
        }
        return r[0];
      };

      IFLLoader.prototype.getTrackForJoint = function(joint, anim) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = anim.tracks.length; _i < _ref; i = _i += 1) {
          if (anim.tracks[i].target.id === joint.name) {
            return anim.tracks[i];
          }
        }
        return null;
      };

      IFLLoader.prototype.convertMaterial = function(subMesh) {
        var matid, params;
        matid = subMesh.material._reference.id;
        if (!this.matCache[matid]) {
          params = {
            color: subMesh.material.diffuse.uintValue,
            ambient: subMesh.material.ambient.uintValue,
            specular: subMesh.material.specular.uintValue,
            map: this.getSubmeshTexture(subMesh.diffuseTextures),
            normalMap: this.getSubmeshTexture(subMesh.normalTextures),
            specularMap: this.getSubmeshTexture(subMesh.specularTextures),
            lightMap: null,
            bumpMap: null,
            reflectivity: subMesh.material.reflectivity,
            opacity: subMesh.material.transparency !== 0 && subMesh.material.transparency !== 1 ? 1 - subMesh.material.transparency : 1,
            wireframe: false,
            side: THREE.DoubleSide,
            transparent: false
          };
          this.matCache[matid] = new THREE.MeshPhongMaterial(params);
        }
        return this.matCache[matid];
      };

      IFLLoader.prototype.getSubmeshTexture = function(from) {
        if (from.length > 0) {
          return this.getTexture(from[0].id, false);
        }
        return null;
      };

      IFLLoader.prototype.getTexture = function(id) {
        var ret, tex;
        tex = this.library.getContent(id);
        if ((tex != null ? tex.converted : void 0) != null) {
          if (!(this.texCache[tex._reference.id] != null)) {
            this.texCache[tex._reference.id] = ret = new THREE.DataTexture(tex.converted, tex._width, tex._height, tex._hasOriginalByteArray ? THREE.RGBFormat : THREE.RGBAFormat);
          } else {
            ret = this.texCache[tex._reference.id];
          }
        }
        if (ret != null) {
          ret.needsUpdate = true;
        }
        if (ret != null) {
          ret.flipY = false;
        }
        return ret;
      };

      IFLLoader.prototype.getCubeTexture = function(array) {
        var image, images, index, path, tex, texture, _i, _len;
        images = [];
        texture = new THREE.Texture();
        texture.image = images;
        texture.flipY = false;
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          path = array[index];
          tex = this.getTexture(path);
          image = tex.image;
          image.format = tex.format;
          images[index] = image;
        }
        texture.needsUpdate = true;
        return texture;
      };

      IFLLoader.prototype.IFLLibraryFuncs = {
        getContent: function(id) {
          return this._contentByID[id];
        },
        getRootNodes: function() {
          return this.getRootNodesIn(this._content);
        },
        isIFLNode: function(object) {
          return object.iflType === "IFLNode" || object.iflType === "IFLJoint" || object.iflType === "IFLMesh" || object.iflType === "IFLMeshContainer" || object.iflType === "IFLLight" || object.iflType === "IFLCamera";
        },
        getDiffuseTexture: function(subMesh) {
          return this.getContent(subMesh._diffuseTextures[0].id);
        },
        getRootNodesIn: function(lib) {
          var k, m, meshesChildrenOfSomeone, meshesNotChildrenOfSomeone, tm, _i, _j, _len, _len1, _ref;
          meshesChildrenOfSomeone = [];
          meshesNotChildrenOfSomeone = [];
          for (_i = 0, _len = lib.length; _i < _len; _i++) {
            tm = lib[_i];
            if (!(this.isIFLNode(tm))) {
              continue;
            }
            if (meshesChildrenOfSomeone.indexOf(tm._reference.id) === -1) {
              meshesNotChildrenOfSomeone.push(tm._reference.id);
            }
            _ref = tm.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              m = _ref[_j];
              if (meshesNotChildrenOfSomeone.indexOf(m.id) !== -1) {
                meshesNotChildrenOfSomeone.splice(meshesNotChildrenOfSomeone.indexOf(m.id), 1);
              }
              meshesChildrenOfSomeone.push(m.id);
            }
          }
          return (function() {
            var _k, _ref1, _results;
            _results = [];
            for (k = _k = 0, _ref1 = meshesNotChildrenOfSomeone.length; _k < _ref1; k = _k += 1) {
              _results.push(this.getContent(meshesNotChildrenOfSomeone[k]));
            }
            return _results;
          }).call(this);
        },
        isRoot: function(contentID) {
          return this.isRootWithin(contentID, this._content);
        },
        isRootWithin: function(contentID, context) {
          var childID, content, _i, _j, _len, _len1, _ref;
          for (_i = 0, _len = context.length; _i < _len; _i++) {
            content = context[_i];
            if (this.isIFLNode(content)) {
              _ref = content.childIDs;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                childID = _ref[_j];
                if (childID.id === contentID) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        findParent: function(node, parent) {
          var ch, childID, p, rootNode, rootNodes, _i, _j, _len, _len1, _ref;
          if (!(parent != null)) {
            rootNodes = this.getRootNodes();
            for (_i = 0, _len = rootNodes.length; _i < _len; _i++) {
              rootNode = rootNodes[_i];
              p = this.findParent(node, rootNode);
              if (p != null) {
                return p;
              }
            }
          } else {
            _ref = parent.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              childID = _ref[_j];
              if (childID.id === node._reference.id) {
                return parent;
              } else {
                ch = this.getContent(childID.id);
                if (ch) {
                  p = this.findParent(node, ch);
                  if (p != null) {
                    return p;
                  }
                }
              }
            }
          }
          return null;
        },
        getAnimationsForSkinJoints: function(skin) {
          var animRet, doneAnims, jobj, joint, jointAnimation, jointAnimations, r, track, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
          r = [];
          doneAnims = [];
          _ref = skin.jointBindings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            jobj = _ref[_i];
            joint = jobj.jointID;
            jointAnimations = this.getAnimationsForID(joint.id, false);
            if ((jointAnimations != null)) {
              for (_j = 0, _len1 = jointAnimations.length; _j < _len1; _j++) {
                jointAnimation = jointAnimations[_j];
                if (!doneAnims[jointAnimation._reference.id]) {
                  doneAnims[jointAnimation._reference.id] = {
                    tracks: [],
                    iflType: "IFLAnimation"
                  };
                  doneAnims[jointAnimation._reference.id]._reference = {
                    id: jointAnimation._reference.id,
                    iflType: "IFLID"
                  };
                  r.push(doneAnims[jointAnimation._reference.id]);
                }
                animRet = doneAnims[jointAnimation._reference.id];
                _ref1 = jointAnimation.tracks;
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  track = _ref1[_k];
                  if (animRet.tracks.indexOf(track) === -1) {
                    animRet.tracks.push(track);
                  }
                }
              }
            }
          }
          return r;
        },
        getAnimationsForID: function(id) {
          var animation, r, track, tracks, _i, _j, _len, _len1, _ref;
          r = [];
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            animation = _ref[_i];
            if (!(animation.iflType === "IFLAnimation")) {
              continue;
            }
            tracks = animation.tracks;
            for (_j = 0, _len1 = tracks.length; _j < _len1; _j++) {
              track = tracks[_j];
              if (track.target.id === id && r.indexOf(animation) === -1) {
                r.push(animation);
              }
            }
          }
          if (r.length > 0) {
            return r;
          }
          return null;
        },
        findJointParent: function(node) {
          var childID, content, _i, _j, _len, _len1, _ref, _ref1;
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            content = _ref[_i];
            if (this.isIFLNode(content)) {
              _ref1 = content.childIDs;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                childID = _ref1[_j];
                if (childID.id === node._reference.id) {
                  if (content.iflType === "IFLJoint") {
                    return content;
                  } else {
                    return this.findJointParent(content);
                  }
                }
              }
            }
          }
          return null;
        }
      };

      return IFLLoader;

    })()
  });

  MaterialManager = (function() {

    MaterialManager.prototype.textureLoader = null;

    MaterialManager.prototype.skyCubeTexture = null;

    function MaterialManager(textureLoader, skyCubeTexture) {
      this.textureLoader = textureLoader;
      this.skyCubeTexture = skyCubeTexture;
    }

    MaterialManager.prototype.getSkyMaterial = function() {};

    MaterialManager.prototype.getCloudMaterial = function() {
      var cloudSprite;
      cloudSprite = this.textureLoader.getTexture("cloud.png");
      return new THREE.ParticleBasicMaterial({
        size: 150,
        map: cloudSprite,
        depthWrite: false,
        transparent: true,
        lights: false
      });
    };

    MaterialManager.prototype.getTerrainPhongMaterial = function() {
      var difftex, difftexB, difftexG, difftexR, lightex, material, parameters, shader, spectex, spectexB, spectexG, spectexR, uniforms;
      shader = THREE.ShaderPhongColor["shader"];
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms["ambient"].value = new THREE.Color(0x222222);
      uniforms["diffuse"].value = new THREE.Color(0xFFFFFF);
      uniforms["specular"].value = new THREE.Color(0x555555);
      difftex = this.textureLoader.getTexture("test_diffuse.jpg");
      difftexR = this.textureLoader.getTexture("test_diffuseR.jpg");
      difftexG = this.textureLoader.getTexture("test_diffuseG.jpg");
      difftexB = this.textureLoader.getTexture("test_diffuseB.jpg");
      difftex.wrapS = difftex.wrapT = THREE.RepeatWrapping;
      difftexR.wrapS = difftexR.wrapT = THREE.RepeatWrapping;
      difftexG.wrapS = difftexG.wrapT = THREE.RepeatWrapping;
      difftexB.wrapS = difftexB.wrapT = THREE.RepeatWrapping;
      uniforms["map"].value = difftex;
      uniforms["enableDiffuseR"].value = true;
      uniforms["enableDiffuseG"].value = true;
      uniforms["enableDiffuseB"].value = true;
      uniforms["tDiffuseR"].value = difftexR;
      uniforms["tDiffuseG"].value = difftexG;
      uniforms["tDiffuseB"].value = difftexB;
      lightex = this.textureLoader.getTexture("test_ao.jpg");
      uniforms["lightMap"].value = lightex;
      spectex = this.textureLoader.getTexture("test_specular.jpg");
      spectexR = this.textureLoader.getTexture("test_specularR.jpg");
      spectexG = this.textureLoader.getTexture("test_specularG.jpg");
      spectexB = this.textureLoader.getTexture("test_specularB.jpg");
      spectex.wrapS = spectex.wrapT = THREE.RepeatWrapping;
      spectexR.wrapS = spectexR.wrapT = THREE.RepeatWrapping;
      spectexG.wrapS = spectexG.wrapT = THREE.RepeatWrapping;
      spectexB.wrapS = spectexB.wrapT = THREE.RepeatWrapping;
      uniforms["specularMap"].value = spectex;
      uniforms["enableSpecularR"].value = true;
      uniforms["enableSpecularG"].value = true;
      uniforms["enableSpecularB"].value = true;
      uniforms["tSpecularR"].value = spectexR;
      uniforms["tSpecularG"].value = spectexG;
      uniforms["tSpecularB"].value = spectexB;
      uniforms["offsetRepeat"].value = new THREE.Vector4(0, 0, 100, 100);
      parameters = {
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: uniforms,
        lights: true,
        vertexColors: THREE.VertexColors
      };
      material = new THREE.ShaderMaterial(parameters);
      material.map = difftex;
      material.specular = new THREE.Color(0xFFFFFF);
      material.shininess = 40;
      material.lightMap = lightex;
      material.specularMap = spectex;
      return material;
    };

    MaterialManager.prototype.getTerrainLambertMaterial = function() {
      var difftex, difftexB, difftexG, difftexR, lightex, material, parameters, shader, uniforms;
      shader = THREE.ShaderLambertColor["shader"];
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms["ambient"].value = new THREE.Color(0x222222);
      uniforms["diffuse"].value = new THREE.Color(0xFFFFFF);
      difftex = this.textureLoader.getTexture("test_diffuse.jpg");
      difftexR = this.textureLoader.getTexture("test_diffuseR.jpg");
      difftexG = this.textureLoader.getTexture("test_diffuseG.jpg");
      difftexB = this.textureLoader.getTexture("test_diffuseB.jpg");
      difftex.wrapS = difftex.wrapT = THREE.RepeatWrapping;
      difftexR.wrapS = difftexR.wrapT = THREE.RepeatWrapping;
      difftexG.wrapS = difftexG.wrapT = THREE.RepeatWrapping;
      difftexB.wrapS = difftexB.wrapT = THREE.RepeatWrapping;
      uniforms["map"].value = difftex;
      uniforms["enableDiffuseR"].value = true;
      uniforms["enableDiffuseG"].value = true;
      uniforms["enableDiffuseB"].value = true;
      uniforms["tDiffuseR"].value = difftexR;
      uniforms["tDiffuseG"].value = difftexG;
      uniforms["tDiffuseB"].value = difftexB;
      uniforms["offsetRepeat"].value = new THREE.Vector4(0, 0, 100, 100);
      lightex = this.textureLoader.getTexture("test2_lightMap.jpg");
      uniforms["lightMap"].value = lightex;
      parameters = {
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: uniforms,
        lights: true,
        vertexColors: THREE.VertexColors
      };
      material = new THREE.ShaderMaterial(parameters);
      material.map = difftex;
      material.lightMap = lightex;
      return material;
    };

    MaterialManager.prototype.getTerrainNormalMaterial = function() {
      var aotex, difftex, difftexB, difftexG, difftexR, material, normaltex, normaltexB, normaltexG, normaltexR, parameters, shader, spectex, spectexB, spectexG, spectexR, uniforms;
      shader = THREE.ShaderNormalColor["shader"];
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      difftex = this.textureLoader.getTexture("test_diffuse.jpg");
      difftexR = this.textureLoader.getTexture("test_diffuseR.jpg");
      difftexG = this.textureLoader.getTexture("test_diffuseG.jpg");
      difftexB = this.textureLoader.getTexture("test_diffuseB.jpg");
      difftex.wrapS = difftex.wrapT = THREE.RepeatWrapping;
      difftexR.wrapS = difftexR.wrapT = THREE.RepeatWrapping;
      difftexG.wrapS = difftexG.wrapT = THREE.RepeatWrapping;
      difftexB.wrapS = difftexB.wrapT = THREE.RepeatWrapping;
      uniforms["enableDiffuse"].value = true;
      uniforms["enableDiffuseR"].value = true;
      uniforms["enableDiffuseG"].value = true;
      uniforms["enableDiffuseB"].value = true;
      uniforms["tDiffuse"].value = difftex;
      uniforms["tDiffuseR"].value = difftexR;
      uniforms["tDiffuseG"].value = difftexG;
      uniforms["tDiffuseB"].value = difftexB;
      normaltex = this.textureLoader.getTexture("test_normal.jpg");
      normaltexR = this.textureLoader.getTexture("test_normalR.jpg");
      normaltexG = this.textureLoader.getTexture("test_normalG.jpg");
      normaltexB = this.textureLoader.getTexture("test_normalB.jpg");
      normaltex.wrapS = normaltex.wrapT = THREE.RepeatWrapping;
      normaltexR.wrapS = normaltexR.wrapT = THREE.RepeatWrapping;
      normaltexG.wrapS = normaltexG.wrapT = THREE.RepeatWrapping;
      normaltexB.wrapS = normaltexB.wrapT = THREE.RepeatWrapping;
      uniforms["enableNormalR"].value = true;
      uniforms["enableNormalG"].value = true;
      uniforms["enableNormalB"].value = true;
      uniforms["tNormal"].value = normaltex;
      uniforms["tNormalR"].value = normaltexR;
      uniforms["tNormalG"].value = normaltexG;
      uniforms["tNormalB"].value = normaltexB;
      uniforms["uNormalScale"].value = new THREE.Vector2(5, 5);
      spectex = this.textureLoader.getTexture("test_specular.jpg");
      spectexR = this.textureLoader.getTexture("test_specularR.jpg");
      spectexG = this.textureLoader.getTexture("test_specularG.jpg");
      spectexB = this.textureLoader.getTexture("test_specularB.jpg");
      spectex.wrapS = spectex.wrapT = THREE.RepeatWrapping;
      spectexR.wrapS = spectexR.wrapT = THREE.RepeatWrapping;
      spectexG.wrapS = spectexG.wrapT = THREE.RepeatWrapping;
      spectexB.wrapS = spectexB.wrapT = THREE.RepeatWrapping;
      uniforms["enableSpecular"].value = true;
      uniforms["enableSpecularR"].value = true;
      uniforms["enableSpecularG"].value = true;
      uniforms["enableSpecularB"].value = true;
      uniforms["tSpecular"].value = spectex;
      uniforms["tSpecularR"].value = spectexR;
      uniforms["tSpecularG"].value = spectexG;
      uniforms["tSpecularB"].value = spectexB;
      aotex = this.textureLoader.getTexture("test_ao.jpg");
      uniforms["enableAO"].value = true;
      uniforms["tAO"].value = aotex;
      uniforms["uDiffuseColor"].value.setHex(0xFFFFFF);
      uniforms["uAmbientColor"].value.setHex(0x222222);
      uniforms["uRepeat"].value = new THREE.Vector2(100, 100);
      uniforms["uShininess"].value = 0;
      uniforms["wrapRGB"].value.set(0.5, 0.5, 0.5);
      parameters = {
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: uniforms,
        lights: true,
        vertexColors: THREE.VertexColors
      };
      material = new THREE.ShaderMaterial(parameters);
      material.wrapAround = true;
      return material;
    };

    MaterialManager.prototype.getLakeMaterial = function() {
      var difftex, difftexR, material, normaltex, normaltexR, parameters, shader, uniforms;
      shader = THREE.ShaderNormalColor["shader"];
      uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      normaltex = this.textureLoader.getTexture("water_norm.jpg");
      normaltex.wrapS = normaltex.wrapT = THREE.RepeatWrapping;
      normaltexR = this.textureLoader.getTexture("foam_norm.jpg");
      normaltexR.wrapS = normaltexR.wrapT = THREE.RepeatWrapping;
      uniforms["tNormal"].value = normaltex;
      uniforms["tNormalR"].value = normaltexR;
      uniforms["enableNormalR"].value = true;
      uniforms["uNormalScale"].value = new THREE.Vector2(3, 3);
      uniforms["tCube"].value = this.skyCubeTexture;
      uniforms["uDiffuseColor"].value.setHex(0xFFFFFF);
      uniforms["uAmbientColor"].value.setHex(0x000000);
      uniforms["uRepeat"].value = new THREE.Vector2(40, 40);
      difftex = this.textureLoader.getTexture("water.jpg");
      difftexR = this.textureLoader.getTexture("foam.jpg");
      difftex.wrapS = difftex.wrapT = THREE.RepeatWrapping;
      difftexR.wrapS = difftexR.wrapT = THREE.RepeatWrapping;
      uniforms["enableDiffuse"].value = true;
      uniforms["tDiffuse"].value = difftex;
      uniforms["enableDiffuseR"].value = true;
      uniforms["tDiffuseR"].value = difftexR;
      uniforms["uOpacity"].value = .8;
      uniforms["enableReflection"].value = true;
      uniforms["uReflectivity"].value = .8;
      parameters = {
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: uniforms,
        lights: true,
        transparent: true,
        vertexColors: THREE.VertexColors
      };
      material = new THREE.ShaderMaterial(parameters);
      material.wrapAround = true;
      material.opacity = .7;
      return material;
    };

    return MaterialManager;

  })();

  App = (function() {

    App.prototype.container = null;

    App.prototype.stats = null;

    App.prototype.camera = null;

    App.prototype.scene = null;

    App.prototype.renderer = null;

    App.prototype.controls = null;

    App.prototype.clock = null;

    App.prototype.renderTarget = null;

    App.prototype.composer = null;

    App.prototype.skyCubeTexture = null;

    App.prototype.skyCube = null;

    App.prototype.terrainLoader = null;

    App.prototype.skyLoader = null;

    App.prototype.lake = null;

    App.prototype.terrain = null;

    App.prototype.cloudsGeometry = null;

    App.prototype.materialManager = null;

    function App() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.onTerrainLoaded = __bind(this.onTerrainLoaded, this);

      this.onTerrainProgress = __bind(this.onTerrainProgress, this);

      this.onTreeLoaded = __bind(this.onTreeLoaded, this);

      this.initSky = __bind(this.initSky, this);

      var ambient, bluriness, effectBloom, hblur, radius, renderModel, renderTargetParameters, sunLight, vblur,
        _this = this;
      this.clock = new THREE.Clock();
      this.container = document.createElement('div');
      document.body.appendChild(this.container);
      this.renderer = new THREE.WebGLRenderer({
        antialias: false
      });
      this.renderer.autoClear = false;
      this.renderer.gammaOutput = true;
      this.renderer.gammaInput = true;
      this.renderer.sortObjects = false;
      this.renderer.shadowMapEnabled = false;
      this.renderer.shadowMapSoft = true;
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
      this.camera.position.z = 10;
      this.camera.target = new THREE.Vector3(0, 0, 0);
      this.scene = new THREE.Scene();
      renderTargetParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat
      };
      this.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetParameters);
      this.composer = new THREE.EffectComposer(this.renderer, this.renderTarget);
      renderModel = new THREE.RenderPass(this.scene, this.camera, null, false, false);
      effectBloom = new THREE.BloomPass(.7);
      hblur = new THREE.ShaderPass(THREE.ShaderExtras["horizontalTiltShift"]);
      vblur = new THREE.ShaderPass(THREE.ShaderExtras["verticalTiltShift"]);
      bluriness = 2;
      hblur.uniforms['h'].value = bluriness / window.innerWidth;
      vblur.uniforms['v'].value = bluriness / window.innerHeight;
      hblur.uniforms['r'].value = vblur.uniforms['r'].value = 0.5;
      this.composer.addPass(renderModel);
      this.composer.addPass(effectBloom);
      this.composer.addPass(hblur);
      this.composer.addPass(vblur);
      vblur.renderToScreen = true;
      sunLight = new THREE.DirectionalLight();
      sunLight.color.setRGB(1, .9, .5);
      sunLight.position.set(-100, 100, -490);
      sunLight.intensity = 1.6;
      sunLight.castShadow = true;
      sunLight.shadowCameraNear = 1;
      sunLight.shadowCameraFar = 2000;
      sunLight.shadowCameraFov = 70;
      sunLight.shadowMapWidth = 512;
      sunLight.shadowMapHeight = 512;
      sunLight.shadowDarkness = .2;
      sunLight.shadowCameraLeft = 400;
      sunLight.shadowCameraRight = -400;
      sunLight.shadowCameraTop = 130;
      sunLight.shadowCameraBottom = -60;
      this.scene.add(sunLight);
      ambient = new THREE.AmbientLight(0xFFFFFF);
      this.scene.add(ambient);
      this.terrainLoader = new ifl.IFLLoader();
      this.terrainLoader.load("models/env.if3d", this.onTerrainLoaded, this.onTerrainProgress);
      this.initSky();
      this.materialManager = new MaterialManager(this.terrainLoader, this.skyCubeTexture);
      this.loader = new ifl.IFLLoader();
      this.loader.load("models/balloon.if3d", function(iflscene) {
        iflscene.scale.set(.05, .05, .05);
        return _this.scene.add(iflscene);
      });
      this.container.appendChild(this.renderer.domElement);
      radius = this.camera.position.z;
      this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      this.container.appendChild(this.stats.domElement);
      window.addEventListener('resize', this.onWindowResize, false);
      this.animate();
      $("body").append("<div id='loading'>Loading Resources<div>");
      $("#loading").append("<div id='progressbar'></div>");
      $("#progressbar").progressbar({
        value: 0
      });
      this.onWindowResize();
      return;
    }

    App.prototype.initSky = function(iflscene) {
      var cubeShader, format, geom, material, path, urls;
      geom = new THREE.CubeGeometry(2000, 2000, 2000);
      path = "models/oldtex/";
      format = '.png';
      urls = [path + 'posx' + format, path + 'negx' + format, path + 'posy' + format, path + 'negy' + format, path + 'negz' + format, path + 'posz' + format];
      this.skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls, null, onload);
      this.skyCubeTexture.format = THREE.RGBFormat;
      cubeShader = THREE.ShaderUtils.lib["cube"];
      cubeShader.uniforms["tCube"].value = this.skyCubeTexture;
      material = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });
      this.skyCube = new THREE.Mesh(geom, material);
      this.skyCube.name = "skyCube";
      this.scene.add(this.skyCube);
    };

    App.prototype.onTreeLoaded = function(iflscene) {
      var averagecolor, child, clouds, cloudsParticleSystem, down, face, geom, grass, i, isAtCloudsLevel, isAtTreesLevel, obj, plantedTrees, rand, start, t, tree, treeind, trees, treesMesh, vert, vertex, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      trees = [];
      _ref = iflscene.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        geom = child.geometry;
        geom.materials[1].transparent = true;
        geom.materials[1].doubleSided = true;
        geom.materials[1].depthWrite = false;
        geom.materials[1].ambient = new THREE.Color(0x333333);
        geom.materials[1].emissive = new THREE.Color(0x333333);
        geom.materials[0].ambient = new THREE.Color(0x333333);
        geom.materials[0].emissive = new THREE.Color(0x333333);
        trees.push(geom);
      }
      start = new THREE.Vector3(0, 1000, 0);
      down = new THREE.Vector3(0, -1, 0);
      plantedTrees = 0;
      treesMesh = [];
      clouds = 0;
      grass = 0;
      t = new Date().getTime();
      this.cloudsGeometry = new THREE.Geometry();
      this.grassGeometry = new THREE.Geometry();
      this.terrain.geometry.computeCentroids();
      _ref1 = this.terrain.geometry.faces;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        face = _ref1[_j];
        vertex = face.centroid;
        isAtTreesLevel = ((-45 < (_ref2 = vertex.y) && _ref2 < -15)) && ((-200 < (_ref3 = vertex.x) && _ref3 < 200)) && ((-200 < (_ref4 = vertex.z) && _ref4 < 200));
        isAtCloudsLevel = ((-40 < (_ref5 = vertex.y) && _ref5 < -20)) && ((-250 < (_ref6 = vertex.x) && _ref6 < 250)) && ((-250 < (_ref7 = vertex.z) && _ref7 < 250));
        if (Math.random() < .09 && isAtTreesLevel) {
          treeind = Math.floor(Math.random() * trees.length);
          rand = -1 + Math.random() * 2;
          tree = new THREE.Mesh(trees[treeind], new THREE.MeshFaceMaterial);
          tree.matrixAutoUpdate = false;
          tree.position.set(vertex.x + rand, vertex.y + 34.6, vertex.z - rand);
          tree.scale.set(.13, .13, .13);
          tree.rotation.y = Math.random() * Math.PI * 2;
          tree.updateMatrix();
          tree.castShadow = tree.receiveShadow = false;
          treesMesh.push(tree);
          plantedTrees++;
        }
        if (Math.random() < .03 && isAtCloudsLevel) {
          vert = new THREE.Vector3(vertex.x, vertex.y + 60, vertex.z);
          vert.origy = vert.y;
          vert.speed = .5 + Math.random() / 2;
          this.cloudsGeometry.vertices.push(vert);
          clouds++;
        }
        averagecolor = face.vertexColors[0];
        if (averagecolor.r === 0 && averagecolor.g === 0 && averagecolor.b === 0 && Math.random() < .1 && isAtTreesLevel) {
          vert = new THREE.Vector3(vertex.x, vertex.y + 36, vertex.z);
          this.grassGeometry.vertices.push(vert);
          for (i = _k = 0; _k < 50; i = _k += 1) {
            vert = new THREE.Vector3(vertex.x + (10 - Math.random() * 20), vertex.y + 35, vertex.z + (10 - Math.random() * 20));
            this.grassGeometry.vertices.push(vert);
          }
          grass++;
        }
      }
      for (_l = 0, _len2 = treesMesh.length; _l < _len2; _l++) {
        obj = treesMesh[_l];
        this.scene.add(obj);
      }
      cloudsParticleSystem = new THREE.ParticleSystem(this.cloudsGeometry, this.materialManager.getCloudMaterial());
      this.scene.add(cloudsParticleSystem);
      console.log("clouds: " + clouds + ", trees: " + plantedTrees + " in " + ((new Date().getTime() - t) / 1000));
      return $("#loading").remove();
    };

    App.prototype.onTerrainProgress = function(loaded, total) {
      return $("#progressbar").progressbar("option", "value", (loaded * 100) / total);
    };

    App.prototype.onTerrainLoaded = function(iflscene) {
      var child, _i, _len, _ref;
      _ref = iflscene.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.name.indexOf("terrain") !== -1) {
          child.material = this.materialManager.getTerrainLambertMaterial();
          this.terrain = child;
          child.receiveShadow = child.castShadow = true;
        } else if (child.name.indexOf("lake") !== -1) {
          this.lake = child;
          child.material = this.materialManager.getLakeMaterial();
          child.castShadow = child.receiveShadow = false;
        }
      }
      iflscene.position.set(0, 35, 0);
      this.scene.add(iflscene);
      this.loader = new ifl.IFLLoader();
      this.loader.load("models/trees.if3d", this.onTreeLoaded);
      return null;
    };

    App.prototype.animate = function() {
      window.requestAnimationFrame(this.animate);
      this.render();
      this.stats.update();
    };

    App.prototype.render = function() {
      var delta, speed, vertex, _i, _len, _ref, _ref1;
      delta = this.clock.getDelta();
      if (this.cloudsGeometry != null) {
        _ref = this.cloudsGeometry.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vertex = _ref[_i];
          speed = this.clock.oldTime / 2000;
          vertex.y = vertex.origy + Math.sin(speed * vertex.speed) * 5;
        }
        this.cloudsGeometry.verticesNeedUpdate = true;
      }
      if ((_ref1 = this.lake) != null) {
        _ref1.material.uniforms["uOffset"].value.y += delta / 40;
      }
      this.renderer.clear();
      this.controls.update();
      this.composer.render(0.1);
      THREE.AnimationHandler.update(delta);
    };

    App.prototype.onWindowResize = function() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderTarget.width = window.innerWidth;
      this.renderTarget.height = window.innerHeight;
      $("#loading").css({
        'position': 'absolute',
        'width': 400,
        "height": 100,
        'left': window.innerWidth / 2 - 200,
        'top': window.innerHeight / 2 - 50
      });
    };

    return App;

  })();

  $(function() {
    return $(document).ready(function() {
      if (!Detector.webgl || !Detector.workers) {
        return Detector.addGetWebGLMessage();
      } else {
        return new App;
      }
    });
  });

}).call(this);
