// Generated by CoffeeScript 1.3.3
(function() {
  var App, IFLLoader, namespace,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  namespace = function(name, values) {
    var key, subpackage, target, value, _i, _len, _ref;
    if (this.hasOwnProperty("window")) {
      target = window;
    } else if (this.hasOwnProperty("exports")) {
      target = exports;
    } else {
      target = this;
    }
    if (name.length > 0) {
      _ref = name.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subpackage = _ref[_i];
        target = target[subpackage] || (target[subpackage] = {});
      }
    }
    for (key in values) {
      value = values[key];
      target[key] = value;
    }
    return target;
  };

  namespace('', {
    namespace: namespace
  });

  namespace("ifl", {
    IFLVertexAttribute: {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    }
  });

  namespace("ifl", {
    IFLLoader: IFLLoader = (function() {

      IFLLoader.prototype.library = null;

      IFLLoader.prototype.callback = null;

      IFLLoader.prototype.callbackProgress = null;

      IFLLoader.prototype.worker = null;

      IFLLoader.prototype.convertTextureIndex = 0;

      IFLLoader.prototype.texCache = null;

      IFLLoader.prototype.matCache = null;

      IFLLoader.prototype.t = 0;

      IFLLoader.prototype.url = null;

      IFLLoader.prototype.loadingPhase = 0;

      IFLLoader.prototype.totalLoadingPhases = 4;

      function IFLLoader() {
        this.onXHRReadyStatusChange = __bind(this.onXHRReadyStatusChange, this);

        this.onXHRProgress = __bind(this.onXHRProgress, this);

        this.onWorkerMessage = __bind(this.onWorkerMessage, this);
        this.worker = new Worker('js/libs/workers.js');
        this.worker.onmessage = this.onWorkerMessage;
        this.texCache = {};
        this.matCache = {};
      }

      IFLLoader.prototype.onWorkerMessage = function(event) {
        var loaded, subtype, total;
        switch (event.data.type) {
          case "console":
            return console[event.data.action](event.data.msg);
          case "progress":
            loaded = event.data.data.progress;
            total = event.data.data.total;
            subtype = event.data.subtype;
            return this.handleProgress(loaded, total);
          default:
            return this[event.data.callback](event.data.data);
        }
      };

      IFLLoader.prototype.handleProgress = function(loaded, total) {
        var currentUnitBase, currentUnitProgress, totalLoaded, unit;
        if (this.callbackProgress != null) {
          unit = 100 / this.totalLoadingPhases;
          currentUnitBase = unit * this.loadingPhase;
          currentUnitProgress = (loaded * unit) / total;
          totalLoaded = currentUnitBase + currentUnitProgress;
          return this.callbackProgress(totalLoaded, 100);
        }
      };

      IFLLoader.prototype.load = function(url, callback, callbackProgress) {
        this.loadingPhase = 0;
        this.url = url;
        this.callback = callback;
        this.callbackProgress = callbackProgress;
        this.xhr = new XMLHttpRequest();
        this.xhr.onreadystatechange = this.onXHRReadyStatusChange;
        this.xhr.onprogress = this.onXHRProgress;
        this.xhr.open("GET", url, true);
        this.xhr.responseType = "arraybuffer";
        return this.xhr.send(null);
      };

      IFLLoader.prototype.onXHRProgress = function(event) {
        return this.handleProgress(event.loaded, event.total);
      };

      IFLLoader.prototype.onXHRReadyStatusChange = function() {
        var response, _ref;
        if (this.xhr.readyState === this.xhr.DONE) {
          if (this.xhr.status === 200 || this.xhr.status === 0) {
            response = (_ref = this.xhr.response) != null ? _ref : this.xhr.mozResponseArrayBuffer;
            this.decompressLibrary(response);
          } else {
            console.error("[ IFLLoader ]: Couldn't load [ " + url + " ] [ " + this.xhr.status + " ]");
          }
        }
      };

      IFLLoader.prototype.decompressLibrary = function(data) {
        this.t = new Date().getTime();
        this.loadingPhase++;
        return this.worker.postMessage({
          type: "inflate",
          data: data,
          callback: "parseLibrary"
        });
      };

      IFLLoader.prototype.parseLibrary = function(data) {
        console.log(("[" + this.url + "] decompression time: ") + (new Date().getTime() - this.t) / 1000);
        this.loadingPhase++;
        this.t = new Date().getTime();
        return this.worker.postMessage({
          type: "convert_library",
          data: data,
          callback: "onLibraryParsed"
        });
      };

      IFLLoader.prototype.onLibraryParsed = function(data) {
        var content, func, _i, _len, _ref;
        this.library = data;
        for (func in this.IFLLibraryFuncs) {
          this.library[func] = this.IFLLibraryFuncs[func];
        }
        this.library._contentByID = {};
        _ref = this.library._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          content = _ref[_i];
          this.library._contentByID[content._reference.id] = content;
        }
        console.log(("[" + this.url + "] library parse time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        this.loadingPhase++;
        return this.convertTextures();
      };

      IFLLoader.prototype.convertTextures = function() {
        var bmp, i, _i, _ref, _ref1;
        for (i = _i = _ref = this.convertTextureIndex, _ref1 = this.library._content.length; _i < _ref1; i = _i += 1) {
          if (this.library._content[i].iflType === "IFLBitmap") {
            bmp = this.library._content[i];
            this.convertTextureIndex = i + 1;
            if (bmp._hasOriginalByteArray) {
              this.worker.postMessage({
                type: "parse_jpg",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            } else {
              this.worker.postMessage({
                type: "convert_argb",
                image: bmp._savedBytes,
                w: bmp._width,
                h: bmp._height,
                callback: "onTextureConverted"
              });
            }
            return;
          }
          this.handleProgress(i, this.library._content.length);
        }
        return this.createModel();
      };

      IFLLoader.prototype.onTextureConverted = function(data) {
        this.library._content[this.convertTextureIndex - 1].converted = data;
        return this.convertTextures();
      };

      IFLLoader.prototype.createModel = function() {
        var root, rootObject, rootObjects, _i, _len;
        console.log(("[" + this.url + "] convert textures time: ") + (new Date().getTime() - this.t) / 1000);
        this.t = new Date().getTime();
        root = new THREE.Object3D();
        rootObjects = this.library.getRootNodes();
        for (_i = 0, _len = rootObjects.length; _i < _len; _i++) {
          rootObject = rootObjects[_i];
          root.add(this.convertNode(rootObject));
        }
        console.log(("[" + this.url + "] convert node time: ") + (new Date().getTime() - this.t) / 1000);
        this.callback(root);
        this.worker.postMessage({
          type: "kill"
        });
      };

      IFLLoader.prototype.convertNode = function(iflnode) {
        var child, childID, mat, retEntity, _i, _len, _ref;
        switch (iflnode.iflType) {
          case "IFLMesh":
            retEntity = this.convertMesh(iflnode);
            break;
          default:
            retEntity = new THREE.Object3D();
        }
        retEntity.name = iflnode._reference.id;
        retEntity.matrix = this.convertMatrix4(iflnode._transformMatrix);
        retEntity.scale.getScaleFromMatrix(retEntity.matrix);
        mat = new THREE.Matrix4().extractRotation(retEntity.matrix);
        retEntity.rotation.setEulerFromRotationMatrix(retEntity.matrix, retEntity.eulerOrder);
        retEntity.position.getPositionFromMatrix(retEntity.matrix);
        _ref = iflnode.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          child = this.library.getContent(childID.id);
          if (child) {
            retEntity.add(this.convertNode(child));
          }
        }
        return retEntity;
      };

      IFLLoader.prototype.convertMatrix4 = function(m) {
        return new THREE.Matrix4(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
      };

      IFLLoader.prototype.convertMesh = function(iflmesh) {
        var bone, color_length, colors, geometry, index, isSkinnedMesh, material, normals, positions, ret, skinIndices, skinWeights, tangents, uvs, _i, _len, _ref;
        positions = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.POSITION];
        uvs = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.UV];
        normals = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.NORMALS];
        tangents = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.TEX_TANGENTS];
        colors = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.COLOR];
        color_length = 0;
        if (colors != null) {
          color_length = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.COLOR];
        }
        skinWeights = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_WEIGHTS];
        skinIndices = iflmesh.verticesDecomposed._data[ifl.IFLVertexAttribute.JOINT_INDICES];
        isSkinnedMesh = skinWeights && skinIndices;
        if (positions.length < 65535 && !isSkinnedMesh && iflmesh.subMeshes.length === 1) {
          geometry = this.convertBufferGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        } else {
          geometry = this.convertGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
        }
        geometry.hasTangents = tangents != null;
        material = iflmesh.subMeshes.length === 1 ? geometry.materials[0] : new THREE.MeshFaceMaterial;
        material.skinning = isSkinnedMesh;
        if (isSkinnedMesh) {
          ret = new THREE.SkinnedMesh(geometry, material);
        } else {
          ret = new THREE.Mesh(geometry, material);
        }
        if (isSkinnedMesh) {
          _ref = ret.geometry.bones;
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            bone = _ref[index];
            ret.boneInverses[index] = bone.invBindMatrix;
          }
        }
        ret.castShadow = ret.receiveShadow = true;
        return ret;
      };

      IFLLoader.prototype.convertBufferGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var geometry, indexBuffer;
        geometry = new THREE.BufferGeometry;
        indexBuffer = iflmesh.subMeshes[0].indexBuffer._rawData;
        geometry.attributes = {};
        geometry.attributes.index = {
          itemSize: 1,
          array: new Int16Array(indexBuffer.length),
          numItems: indexBuffer.length
        };
        geometry.attributes.index.array.set(indexBuffer);
        geometry.attributes.position = {
          itemSize: 3,
          array: positions,
          numItems: positions.length
        };
        if (uvs) {
          geometry.attributes.uv = {
            itemSize: 2,
            array: uvs,
            numItems: uvs.length
          };
        }
        if (normals) {
          geometry.attributes.normal = {
            itemSize: 3,
            array: normals,
            numItems: normals.length
          };
        }
        if (colors) {
          geometry.attributes.color = {
            itemSize: color_length,
            array: colors.length,
            numItems: colors.length
          };
        }
        if (tangents) {
          geometry.attributes.tangent = {
            itemSize: 3,
            array: tangents,
            numItems: tangents.length
          };
        }
        geometry.offsets = [
          {
            start: 0,
            count: indexBuffer.length,
            index: 0
          }
        ];
        geometry.materials = [this.convertMaterial(iflmesh.subMeshes[0])];
        return geometry;
      };

      IFLLoader.prototype.convertGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
        var cachedColors, cachedNormals, cachedTangents, cachedUVs, face, faceIndex, fakeUV, fvUVs, geometry, i, i1, i12, i13, i14, i2, i22, i23, i24, i3, i32, i33, i34, ib, ibi, material, second, stepSize, subMesh, subMeshIndex, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _step;
        console.warn("Mesh " + iflmesh._reference.id + " converted as standard THREE.Geometry");
        geometry = new THREE.Geometry;
        cachedUVs = [];
        cachedNormals = [];
        cachedTangents = [];
        cachedColors = [];
        if (positions) {
          for (i = _i = 0, _ref = positions.length; _i < _ref; i = _i += 3) {
            geometry.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
          }
        } else {
          return new THREE.Object3D();
        }
        if (isSkinnedMesh) {
          stepSize = iflmesh.verticesDecomposed._vertexAttributeLengths[ifl.IFLVertexAttribute.JOINT_INDICES];
          if (stepSize <= 2) {
            for (i = _j = 0, _ref1 = skinIndices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += stepSize) {
              second = Math.floor(i + stepSize / 2);
              geometry.skinWeights.push(new THREE.Vector4(skinWeights[i], skinWeights[second], 0, 0));
              geometry.skinIndices.push(new THREE.Vector4(skinIndices[i], skinIndices[second], 0, 0));
            }
          }
          geometry.bones = this.convertBones(iflmesh);
          geometry.animation = this.convertAnimations(geometry.bones, iflmesh);
        }
        fakeUV = new THREE.UV(0, 0);
        _ref2 = iflmesh.subMeshes;
        for (subMeshIndex = _k = 0, _len = _ref2.length; _k < _len; subMeshIndex = ++_k) {
          subMesh = _ref2[subMeshIndex];
          material = this.convertMaterial(subMesh);
          material.skinning = isSkinnedMesh;
          geometry.materials.push(material);
          ib = subMesh.indexBuffer._rawData;
          for (ibi = _l = 0, _len1 = ib.length, _step = 3; _l < _len1; ibi = _l += _step) {
            i1 = ib[ibi];
            i2 = ib[ibi + 1];
            i3 = ib[ibi + 2];
            i12 = i1 * 2;
            i22 = i2 * 2;
            i32 = i3 * 2;
            i13 = i1 * 3;
            i23 = i2 * 3;
            i33 = i3 * 3;
            i14 = i1 * 4;
            i24 = i2 * 4;
            i34 = i3 * 4;
            face = new THREE.Face3(i1, i2, i3, null, null, subMeshIndex);
            faceIndex = geometry.faces.length;
            fvUVs = geometry.faceVertexUvs[0][faceIndex] = [];
            if (uvs != null) {
              fvUVs.push(cachedUVs[i12] ? cachedUVs[i12] : cachedUVs[i12] = new THREE.UV(uvs[i12], uvs[i12 + 1]));
              fvUVs.push(cachedUVs[i22] ? cachedUVs[i22] : cachedUVs[i22] = new THREE.UV(uvs[i22], uvs[i22 + 1]));
              fvUVs.push(cachedUVs[i32] ? cachedUVs[i32] : cachedUVs[i32] = new THREE.UV(uvs[i32], uvs[i32 + 1]));
            }
            if (normals != null) {
              face.vertexNormals.push(cachedNormals[i13] ? cachedNormals[i13] : cachedNormals[i13] = new THREE.Vector3(normals[i13], normals[i13 + 1], normals[i13 + 2]));
              face.vertexNormals.push(cachedNormals[i23] ? cachedNormals[i23] : cachedNormals[i23] = new THREE.Vector3(normals[i23], normals[i23 + 1], normals[i23 + 2]));
              face.vertexNormals.push(cachedNormals[i33] ? cachedNormals[i33] : cachedNormals[i33] = new THREE.Vector3(normals[i33], normals[i33 + 1], normals[i33 + 2]));
            }
            if (tangents != null) {
              face.vertexTangents.push(cachedTangents[i13] ? cachedTangents[i13] : cachedTangents[i13] = new THREE.Vector4(tangents[i13], tangents[i13 + 1], tangents[i13 + 2], 1));
              face.vertexTangents.push(cachedTangents[i23] ? cachedTangents[i23] : cachedTangents[i23] = new THREE.Vector4(tangents[i23], tangents[i23 + 1], tangents[i23 + 2], 1));
              face.vertexTangents.push(cachedTangents[i33] ? cachedTangents[i33] : cachedTangents[i33] = new THREE.Vector4(tangents[i33], tangents[i33 + 1], tangents[i33 + 2], 1));
            }
            if (colors != null) {
              if (color_length === 3) {
                face.vertexColors.push(cachedColors[i13] ? cachedColors[i13] : cachedColors[i13] = new THREE.Color().setRGB(colors[i13], colors[i13 + 1], colors[i13 + 2]));
                face.vertexColors.push(cachedColors[i23] ? cachedColors[i23] : cachedColors[i23] = new THREE.Color().setRGB(colors[i23], colors[i23 + 1], colors[i23 + 2]));
                face.vertexColors.push(cachedColors[i33] ? cachedColors[i33] : cachedColors[i33] = new THREE.Color().setRGB(colors[i33], colors[i33 + 1], colors[i33 + 2]));
              }
              if (color_length === 4) {
                face.vertexColors.push(cachedColors[i14] ? cachedColors[i14] : cachedColors[i14] = new THREE.Color().setRGB(colors[i14], colors[i14 + 1], colors[i14 + 2]));
                face.vertexColors.push(cachedColors[i24] ? cachedColors[i24] : cachedColors[i24] = new THREE.Color().setRGB(colors[i24], colors[i24 + 1], colors[i24 + 2]));
                face.vertexColors.push(cachedColors[i34] ? cachedColors[i34] : cachedColors[i34] = new THREE.Color().setRGB(colors[i34], colors[i34 + 1], colors[i34 + 2]));
              }
            }
            geometry.faces.push(face);
          }
        }
        if (isSkinnedMesh) {
          geometry.computeCentroids();
          geometry.computeFaceNormals();
          try {
            geometry.computeTangents();
          } catch (e) {
            console.warn("error computing tangents");
          }
        }
        return geometry;
      };

      IFLLoader.prototype.convertBones = function(iflmesh) {
        var bind, bindingToJoint, bindings, bindpose, decomp, i, iflparent, invBindMatrix, jo, joint, jointMatrix, jointToBinding, jointToIndex, joints, p, parent, pos, root, rotq, scale, sk, skeletonJoint, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
        joints = [];
        jointToBinding = [];
        bindingToJoint = [];
        bindings = iflmesh.jointBindings;
        for (i = _i = 0, _ref = bindings.length; _i < _ref; i = _i += 1) {
          jo = this.library.getContent(bindings[i].jointID.id);
          if (!(jo != null)) {
            return null;
          }
          jointToBinding[jo._reference.id] = i;
          bindingToJoint[i] = jo._reference.id;
          joints.push(jo);
        }
        for (_j = 0, _len = joints.length; _j < _len; _j++) {
          joint = joints[_j];
          if (!this.library.findJointParent(joint)) {
            root = joint;
            break;
          }
        }
        bindpose = this.convertMatrix4(iflmesh.bindPoseMatrix);
        sk = [];
        sk.name = root.id;
        jointToIndex = [];
        skeletonJoint;

        for (i = _k = 0, _ref1 = bindings.length; _k < _ref1; i = _k += 1) {
          skeletonJoint = {};
          skeletonJoint.name = joints[i]._reference.id;
          jointMatrix = this.convertMatrix4(joints[i]._transformMatrix);
          invBindMatrix = this.convertMatrix4(bindings[i].inverseBindMatrix);
          decomp = jointMatrix.decompose();
          skeletonJoint.pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          skeletonJoint.rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          jointToIndex[skeletonJoint.name] = sk.length;
          skeletonJoint.invBindMatrix = invBindMatrix;
          skeletonJoint.jointMatrix = jointMatrix;
          sk.push(skeletonJoint);
        }
        for (i = _l = 0, _ref2 = bindings.length; _l < _ref2; i = _l += 1) {
          skeletonJoint = sk[i];
          parent = this.library.findJointParent(joints[i]);
          if (!(parent != null)) {
            skeletonJoint.parent = -1;
          } else {
            if (parent.iflType === "IFLJoint") {
              if (jointToIndex[parent._reference.id] !== void 0) {
                skeletonJoint.parent = jointToIndex[parent._reference.id];
              } else {
                skeletonJoint.parent = -1;
              }
            } else {
              skeletonJoint.parent = -1;
            }
          }
        }
        for (i = _m = 0, _ref3 = bindings.length; _m < _ref3; i = _m += 1) {
          skeletonJoint = sk[i];
          bind = skeletonJoint.invBindMatrix.clone();
          scale = this.setScale1(bind);
          bind.getInverse(bind);
          if (i !== 0) {
            p = sk[skeletonJoint.parent];
            bind.multiply(p.invBindMatrix, bind);
            iflparent = this.library.findParent(this.library.getContent(skeletonJoint.name));
            if (iflparent.iflType !== "IFLJoint") {
              this.prependNonJointParents(bind, iflparent);
            }
          } else {
            bind.multiply(bindpose, bind);
          }
          decomp = bind.decompose();
          pos = [decomp[0].x, decomp[0].y, decomp[0].z];
          rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
          skeletonJoint.pos = pos;
          skeletonJoint.rotq = rotq;
        }
        return sk;
      };

      IFLLoader.prototype.prependNonJointParents = function(bind, iflparent) {
        var otherparent, parentmat, prepended;
        parentmat = this.convertMatrix4(iflparent._transformMatrix);
        prepended = new THREE.Matrix4().multiply(parentmat, bind);
        bind.copy(prepended);
        otherparent = this.library.findParent(iflparent);
        if (otherparent.iflType !== "IFLJoint") {
          return this.prependNonJointParents(bind, otherparent);
        }
      };

      IFLLoader.prototype.setScale1 = function(m) {
        var x, y, z;
        x = new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).length();
        y = new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).length();
        z = new THREE.Vector3(m.elements[8], m.elements[9], m.elements[10]).length();
        m.elements[0] /= x;
        m.elements[1] /= x;
        m.elements[2] /= x;
        m.elements[4] /= y;
        m.elements[5] /= y;
        m.elements[6] /= y;
        m.elements[8] /= z;
        m.elements[9] /= z;
        m.elements[10] /= z;
        m.elements[12] /= x;
        m.elements[13] /= y;
        m.elements[14] /= z;
        m.elements[15] = 1;
        return new THREE.Vector3(x, y, z);
      };

      IFLLoader.prototype.findJointParent = function(joint, root) {
        var childID, p, _i, _len, _ref;
        if (!(root != null)) {
          return null;
        }
        _ref = root.childIDs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childID = _ref[_i];
          if (childID.id === joint._reference.id) {
            return root;
          } else {
            p = findJointParent(joint, this.library.getContent(childID.id));
            if (p) {
              return p;
            }
          }
        }
        return null;
      };

      IFLLoader.prototype.convertAnimations = function(skeleton, iflMesh) {
        var anim, anim3js, anims, bindpose, firstKey, i, j, k, key3js, keys, lastkey, maxTime, numTimes, r, sampler, stillMatDec, stillPos, stillRot, timePerFrame, totalMaxTime, track, track3js, trackLength, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
        anims = this.library.getAnimationsForSkinJoints(iflMesh);
        r = [];
        bindpose = this.convertMatrix4(iflMesh.bindPoseMatrix);
        if (anims.length === 0) {
          anims[0] = {
            _reference: {
              id: "fake"
            },
            tracks: []
          };
        }
        for (i = _i = 0; _i < 1; i = _i += 1) {
          anim3js = {};
          anim3js.name = iflMesh._reference.id + "_" + anims[i]._reference.id;
          anim3js.fps = 30;
          anim3js.hierarchy = [];
          totalMaxTime = 0;
          for (k = _j = 0, _ref = skeleton.length; _j < _ref; k = _j += 1) {
            track = this.getTrackForJoint(skeleton[k], anims[i]);
            stillMatDec = skeleton[k].jointMatrix.decompose();
            maxTime = 0;
            stillPos = skeleton[k].pos;
            stillRot = skeleton[k].rotq;
            if (track != null) {
              track3js = {};
              track3js.parent = skeleton[k].parent;
              track3js.name = "track_" + skeleton[k].name;
              track3js.keys = [];
              sampler = track.sampler;
              trackLength = track.end - track.start;
              numTimes = sampler.times.length;
              timePerFrame = (trackLength / numTimes) * 1000;
              for (j = _k = 0, _ref1 = sampler.times.length; _k < _ref1; j = _k += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [sampler.positions[j].x, sampler.positions[j].y, sampler.positions[j].z];
                key3js.rot = [sampler.orientations[j].x, sampler.orientations[j].y, sampler.orientations[j].z, sampler.orientations[j].w];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            } else {
              console.log("no track for joint " + skeleton[k].name + " creating a fake one");
              anim = anims[i];
              sampler = anim.tracks.length > 0 ? anim.tracks[0].sampler : {
                times: [0, 1]
              };
              track3js = {};
              track3js.name = "fake_track_" + skeleton[k].name;
              track3js.parent = skeleton[k].parent;
              track3js.keys = [];
              for (j = _l = 0, _ref2 = sampler.times.length; _l < _ref2; j = _l += 1) {
                key3js = {};
                key3js.time = sampler.times[j];
                maxTime = Math.max(key3js.time, maxTime);
                totalMaxTime = Math.max(maxTime, totalMaxTime);
                key3js.pos = [stillPos[0], stillPos[1], stillPos[2]];
                key3js.rot = [stillRot[0], stillRot[1], stillRot[2], stillRot[3]];
                key3js.scl = [1, 1, 1];
                track3js.keys.push(key3js);
              }
            }
            anim3js.length = maxTime;
            anim3js.hierarchy.push(track3js);
          }
          for (k = _m = 0, _ref3 = anim3js.hierarchy.length; _m < _ref3; k = _m += 1) {
            keys = anim3js.hierarchy[k].keys;
            lastkey = keys[keys.length - 1];
            firstKey = keys[0];
            if (lastkey.time < totalMaxTime) {
              keys.push({
                time: totalMaxTime,
                pos: lastkey.pos,
                rot: lastkey.rot,
                scl: lastkey.scl
              });
            }
            if (firstKey.time > 0) {
              keys.unshift({
                time: 0,
                pos: firstKey.pos,
                rot: firstKey.rot,
                scl: firstKey.scl
              });
            }
          }
          anim3js.length = totalMaxTime;
          r.push(anim3js);
        }
        return r[0];
      };

      IFLLoader.prototype.getTrackForJoint = function(joint, anim) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = anim.tracks.length; _i < _ref; i = _i += 1) {
          if (anim.tracks[i].target.id === joint.name) {
            return anim.tracks[i];
          }
        }
        return null;
      };

      IFLLoader.prototype.convertMaterial = function(subMesh) {
        var matid, params;
        matid = subMesh.material._reference.id;
        if (!this.matCache[matid]) {
          params = {
            color: subMesh.material.diffuse.uintValue,
            ambient: subMesh.material.ambient.uintValue,
            specular: subMesh.material.specular.uintValue,
            map: this.getSubmeshTexture(subMesh.diffuseTextures),
            normalMap: this.getSubmeshTexture(subMesh.normalTextures),
            specularMap: this.getSubmeshTexture(subMesh.specularTextures),
            lightMap: null,
            bumpMap: null,
            reflectivity: subMesh.material.reflectivity,
            opacity: subMesh.material.transparency !== 0 && subMesh.material.transparency !== 1 ? 1 - subMesh.material.transparency : 1,
            wireframe: false,
            side: THREE.DoubleSide,
            transparent: false
          };
          this.matCache[matid] = new THREE.MeshPhongMaterial(params);
        }
        return this.matCache[matid];
      };

      IFLLoader.prototype.getSubmeshTexture = function(from) {
        if (from.length > 0) {
          return this.getTexture(from[0].id, false);
        }
        return null;
      };

      IFLLoader.prototype.getTexture = function(id) {
        var ret, tex;
        tex = this.library.getContent(id);
        if ((tex != null ? tex.converted : void 0) != null) {
          if (!(this.texCache[tex._reference.id] != null)) {
            this.texCache[tex._reference.id] = ret = new THREE.DataTexture(tex.converted, tex._width, tex._height, tex._hasOriginalByteArray ? THREE.RGBFormat : THREE.RGBAFormat);
          } else {
            ret = this.texCache[tex._reference.id];
          }
        }
        if (ret != null) {
          ret.needsUpdate = true;
        }
        if (ret != null) {
          ret.flipY = false;
        }
        return ret;
      };

      IFLLoader.prototype.getCubeTexture = function(array) {
        var image, images, index, path, tex, texture, _i, _len;
        images = [];
        texture = new THREE.Texture();
        texture.image = images;
        texture.flipY = false;
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          path = array[index];
          tex = this.getTexture(path);
          image = tex.image;
          image.format = tex.format;
          images[index] = image;
        }
        texture.needsUpdate = true;
        return texture;
      };

      IFLLoader.prototype.IFLLibraryFuncs = {
        getContent: function(id) {
          return this._contentByID[id];
        },
        getRootNodes: function() {
          return this.getRootNodesIn(this._content);
        },
        isIFLNode: function(object) {
          return object.iflType === "IFLNode" || object.iflType === "IFLJoint" || object.iflType === "IFLMesh" || object.iflType === "IFLMeshContainer" || object.iflType === "IFLLight" || object.iflType === "IFLCamera";
        },
        getDiffuseTexture: function(subMesh) {
          return this.getContent(subMesh._diffuseTextures[0].id);
        },
        getRootNodesIn: function(lib) {
          var k, m, meshesChildrenOfSomeone, meshesNotChildrenOfSomeone, tm, _i, _j, _len, _len1, _ref;
          meshesChildrenOfSomeone = [];
          meshesNotChildrenOfSomeone = [];
          for (_i = 0, _len = lib.length; _i < _len; _i++) {
            tm = lib[_i];
            if (!(this.isIFLNode(tm))) {
              continue;
            }
            if (meshesChildrenOfSomeone.indexOf(tm._reference.id) === -1) {
              meshesNotChildrenOfSomeone.push(tm._reference.id);
            }
            _ref = tm.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              m = _ref[_j];
              if (meshesNotChildrenOfSomeone.indexOf(m.id) !== -1) {
                meshesNotChildrenOfSomeone.splice(meshesNotChildrenOfSomeone.indexOf(m.id), 1);
              }
              meshesChildrenOfSomeone.push(m.id);
            }
          }
          return (function() {
            var _k, _ref1, _results;
            _results = [];
            for (k = _k = 0, _ref1 = meshesNotChildrenOfSomeone.length; _k < _ref1; k = _k += 1) {
              _results.push(this.getContent(meshesNotChildrenOfSomeone[k]));
            }
            return _results;
          }).call(this);
        },
        isRoot: function(contentID) {
          return this.isRootWithin(contentID, this._content);
        },
        isRootWithin: function(contentID, context) {
          var childID, content, _i, _j, _len, _len1, _ref;
          for (_i = 0, _len = context.length; _i < _len; _i++) {
            content = context[_i];
            if (this.isIFLNode(content)) {
              _ref = content.childIDs;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                childID = _ref[_j];
                if (childID.id === contentID) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        findParent: function(node, parent) {
          var ch, childID, p, rootNode, rootNodes, _i, _j, _len, _len1, _ref;
          if (!(parent != null)) {
            rootNodes = this.getRootNodes();
            for (_i = 0, _len = rootNodes.length; _i < _len; _i++) {
              rootNode = rootNodes[_i];
              p = this.findParent(node, rootNode);
              if (p != null) {
                return p;
              }
            }
          } else {
            _ref = parent.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              childID = _ref[_j];
              if (childID.id === node._reference.id) {
                return parent;
              } else {
                ch = this.getContent(childID.id);
                if (ch) {
                  p = this.findParent(node, ch);
                  if (p != null) {
                    return p;
                  }
                }
              }
            }
          }
          return null;
        },
        getAnimationsForSkinJoints: function(skin) {
          var animRet, doneAnims, jobj, joint, jointAnimation, jointAnimations, r, track, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
          r = [];
          doneAnims = [];
          _ref = skin.jointBindings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            jobj = _ref[_i];
            joint = jobj.jointID;
            jointAnimations = this.getAnimationsForID(joint.id, false);
            if ((jointAnimations != null)) {
              for (_j = 0, _len1 = jointAnimations.length; _j < _len1; _j++) {
                jointAnimation = jointAnimations[_j];
                if (!doneAnims[jointAnimation._reference.id]) {
                  doneAnims[jointAnimation._reference.id] = {
                    tracks: [],
                    iflType: "IFLAnimation"
                  };
                  doneAnims[jointAnimation._reference.id]._reference = {
                    id: jointAnimation._reference.id,
                    iflType: "IFLID"
                  };
                  r.push(doneAnims[jointAnimation._reference.id]);
                }
                animRet = doneAnims[jointAnimation._reference.id];
                _ref1 = jointAnimation.tracks;
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  track = _ref1[_k];
                  if (animRet.tracks.indexOf(track) === -1) {
                    animRet.tracks.push(track);
                  }
                }
              }
            }
          }
          return r;
        },
        getAnimationsForID: function(id) {
          var animation, r, track, tracks, _i, _j, _len, _len1, _ref;
          r = [];
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            animation = _ref[_i];
            if (!(animation.iflType === "IFLAnimation")) {
              continue;
            }
            tracks = animation.tracks;
            for (_j = 0, _len1 = tracks.length; _j < _len1; _j++) {
              track = tracks[_j];
              if (track.target.id === id && r.indexOf(animation) === -1) {
                r.push(animation);
              }
            }
          }
          if (r.length > 0) {
            return r;
          }
          return null;
        },
        findJointParent: function(node) {
          var childID, content, _i, _j, _len, _len1, _ref, _ref1;
          _ref = this._content;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            content = _ref[_i];
            if (this.isIFLNode(content)) {
              _ref1 = content.childIDs;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                childID = _ref1[_j];
                if (childID.id === node._reference.id) {
                  if (content.iflType === "IFLJoint") {
                    return content;
                  } else {
                    return this.findJointParent(content);
                  }
                }
              }
            }
          }
          return null;
        }
      };

      return IFLLoader;

    })()
  });

  App = (function() {

    App.prototype.stats = null;

    App.prototype.camera = null;

    App.prototype.scene = null;

    App.prototype.renderer = null;

    App.prototype.controls = null;

    App.prototype.clock = null;

    App.prototype.renderTarget = null;

    App.prototype.composer = null;

    App.prototype.APP_HEIGHT = 800;

    App.prototype.APP_WIDTH = 600;

    App.prototype.APP_HALF_X = 800 / 2;

    App.prototype.APP_HALF_Y = 600 / 2;

    App.prototype.mouseX = 0;

    App.prototype.mouseY = 0;

    App.prototype.skyCubeTexture = null;

    App.prototype.skyCube = null;

    App.prototype.bigWheel = null;

    App.prototype.crousel = null;

    App.prototype.ground = null;

    App.prototype.pointer = null;

    App.prototype.pickMouse = null;

    App.prototype.projector = null;

    function App() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.initPathControls = __bind(this.initPathControls, this);

      this.onWorldLoaded = __bind(this.onWorldLoaded, this);

      this.onWorldProgress = __bind(this.onWorldProgress, this);

      this.onTouchMove = __bind(this.onTouchMove, this);

      this.onTouchStart = __bind(this.onTouchStart, this);

      this.onMouseMove = __bind(this.onMouseMove, this);

      this.onMouseClick = __bind(this.onMouseClick, this);

      var ambient, bluriness, effectBloom, effectFilm, fxaa, hblur, renderModel, renderTargetParameters, renderToScreenPass, vblur;
      this.clock = new THREE.Clock();
      this.pickMouse = {
        x: 0,
        y: 0
      };
      this.projector = new THREE.Projector();
      $("body").append('<div id="container"></div>');
      this.APP_WIDTH = $(window).width();
      this.APP_HEIGHT = $(window).height();
      this.renderer = new THREE.WebGLRenderer({
        antialias: false,
        stencil: false
      });
      this.renderer.autoClear = false;
      this.renderer.gammaOutput = true;
      this.renderer.gammaInput = true;
      this.renderer.sortObjects = false;
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapSoft = true;
      this.renderer.setSize(this.APP_WIDTH, this.APP_HEIGHT);
      this.camera = new THREE.PerspectiveCamera(50, this.APP_WIDTH / this.APP_HEIGHT, 10, 100000);
      this.scene = new THREE.Scene();
      renderTargetParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat
      };
      this.renderTarget = new THREE.WebGLRenderTarget(this.APP_WIDTH, this.APP_HEIGHT, renderTargetParameters);
      this.composer = new THREE.EffectComposer(this.renderer, this.renderTarget);
      renderModel = new THREE.RenderPass(this.scene, this.camera, null, false, false);
      effectBloom = new THREE.BloomPass(1);
      effectFilm = new THREE.FilmPass(0.10, 0.20, this.APP_HEIGHT * 2, false);
      fxaa = new THREE.ShaderPass(THREE.ShaderExtras["fxaa"]);
      fxaa.uniforms['resolution'].value = new THREE.Vector2(1 / this.APP_WIDTH, 1 / this.APP_HEIGHT);
      hblur = new THREE.ShaderPass(THREE.ShaderExtras["horizontalTiltShift"]);
      vblur = new THREE.ShaderPass(THREE.ShaderExtras["verticalTiltShift"]);
      bluriness = 2;
      hblur.uniforms['h'].value = bluriness / this.APP_WIDTH;
      vblur.uniforms['v'].value = bluriness / this.APP_HEIGHT;
      hblur.uniforms['r'].value = vblur.uniforms['r'].value = 0.5;
      this.composer.addPass(renderModel);
      this.composer.addPass(effectBloom);
      this.composer.addPass(effectFilm);
      renderToScreenPass = new THREE.ShaderPass(THREE.ShaderExtras["screen"]);
      renderToScreenPass.renderToScreen = true;
      this.composer.addPass(renderToScreenPass);
      ambient = new THREE.AmbientLight(0xFFFFFF);
      this.scene.add(ambient);
      this.initSky();
      this.initSun();
      $.getJSON('js/camerapath.json', this.initPathControls);
      this.loader = new ifl.IFLLoader();
      this.loader.load("models/fair_hi.if3d", this.onWorldLoaded, this.onWorldProgress);
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      window.addEventListener('resize', this.onWindowResize, false);
      document.addEventListener('mousemove', this.onMouseMove, false);
      document.addEventListener('mousedown', this.onMouseClick, false);
      document.addEventListener('touchstart', this.onTouchStart, false);
      document.addEventListener('touchmove', this.onTouchMove, false);
      this.animate();
      $("#container").append(this.stats.domElement);
      $("#container").append(this.renderer.domElement);
      $("#container").append("<div id='loading'>Loading Resources<div>");
      $("#loading").append("<div id='progressbar'></div>");
      $("#progressbar").progressbar({
        value: 0
      });
      this.onWindowResize();
      return;
    }

    App.prototype.onMouseClick = function(event) {};

    App.prototype.onMouseMove = function(event) {
      this.mouseX = event.pageX - this.APP_HALF_X;
      this.mouseY = event.pageY - this.APP_HALF_Y;
      this.pickMouse.x = (event.clientX / this.APP_WIDTH) * 2 - 1;
      return this.pickMouse.y = -(event.clientY / this.APP_HEIGHT) * 2 + 1;
    };

    App.prototype.onTouchStart = function(event) {
      var mouseX, mouseY;
      if (event.touches.length === 1) {
        event.preventDefault();
        mouseX = event.touches[0].pageX - this.APP_HALF_X;
        return mouseY = event.touches[0].pageY - this.APP_HALF_Y;
      }
    };

    App.prototype.onTouchMove = function(event) {
      var mouseX, mouseY;
      if (event.touches.length === 1) {
        event.preventDefault();
        mouseX = event.touches[0].pageX - this.APP_HALF_X;
        return mouseY = event.touches[0].pageY - this.APP_HALF_Y;
      }
    };

    App.prototype.onWorldProgress = function(loaded, total) {
      return $("#progressbar").progressbar("option", "value", (loaded * 100) / total);
    };

    App.prototype.onWorldLoaded = function(iflscene) {
      var descendant, descendants, _i, _len;
      descendants = iflscene.getDescendants();
      for (_i = 0, _len = descendants.length; _i < _len; _i++) {
        descendant = descendants[_i];
        if (descendant.name.toLowerCase().indexOf("big_wheel") !== -1) {
          this.bigWheel = descendant;
        }
        if (descendant.name.toLowerCase().indexOf("carrousel") !== -1) {
          this.carousel = descendant;
        }
      }
      this.scene.add(iflscene);
      this.controls.animation.play(true, 0);
      return $("#loading").remove();
    };

    App.prototype.initPathControls = function(data) {
      this.controls = new THREE.PathControls(this.camera);
      this.controls.waypoints = data.waypoints;
      this.controls.duration = 100;
      this.controls.useConstantSpeed = true;
      this.controls.createDebugPath = false;
      this.controls.createDebugDummy = false;
      this.controls.lookSpeed = 0.5;
      this.controls.lookVertical = true;
      this.controls.lookHorizontal = true;
      this.controls.verticalAngleMap = {
        srcRange: [0, 2 * Math.PI],
        dstRange: [1.3, 2.2]
      };
      this.controls.horizontalAngleMap = {
        srcRange: [0, 2 * Math.PI],
        dstRange: [1, Math.PI - 1]
      };
      this.controls.init();
      this.scene.add(this.controls.debugPath);
      return this.scene.add(this.controls.animationParent);
    };

    App.prototype.createPyramid = function(x, y, w, h, d) {
      var bottomFace, geometry, leftFace, material, rightFace, topFace;
      geometry = new THREE.Geometry();
      topFace = new THREE.Face3(2, 1, 0);
      geometry.vertices.push(new THREE.Vector3(x, y, 0));
      geometry.vertices.push(new THREE.Vector3(x + w, y, 0));
      geometry.vertices.push(new THREE.Vector3(x + w / 2, y + h / 2, d));
      rightFace = new THREE.Face3(5, 4, 3);
      geometry.vertices.push(new THREE.Vector3(x + w, y, 0));
      geometry.vertices.push(new THREE.Vector3(x + w, y + h, 0));
      geometry.vertices.push(new THREE.Vector3(x + w / 2, y + h / 2, d));
      bottomFace = new THREE.Face3(8, 7, 6);
      geometry.vertices.push(new THREE.Vector3(x, y + h, 0));
      geometry.vertices.push(new THREE.Vector3(x + w, y + h, 0));
      geometry.vertices.push(new THREE.Vector3(x + w / 2, y + h / 2, d));
      leftFace = new THREE.Face3(11, 10, 9);
      geometry.vertices.push(new THREE.Vector3(x, y, 0));
      geometry.vertices.push(new THREE.Vector3(x, y + h, 0));
      geometry.vertices.push(new THREE.Vector3(x + w / 2, y + h / 2, d));
      geometry.faces.push(topFace);
      geometry.faces.push(rightFace);
      geometry.faces.push(bottomFace);
      geometry.faces.push(leftFace);
      geometry.computeCentroids();
      geometry.computeFaceNormals();
      geometry.computeVertexNormals();
      material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        color: 0xFF0000,
        ambient: 0x333333
      });
      return new THREE.Mesh(geometry, material);
    };

    App.prototype.initSun = function() {
      var flareColor, lensFlare, sunLight, textureFlare0, textureFlare2, textureFlare3,
        _this = this;
      sunLight = new THREE.DirectionalLight();
      sunLight.color.setRGB(1, 1, 1);
      sunLight.position.set(5000, 5000, -5000);
      sunLight.intensity = 1.3;
      sunLight.castShadow = true;
      sunLight.shadowCameraNear = 20;
      sunLight.shadowCameraFar = 100000;
      sunLight.shadowCameraFov = 70;
      sunLight.shadowMapWidth = 1024;
      sunLight.shadowMapHeight = 1024;
      sunLight.shadowDarkness = .2;
      sunLight.shadowCameraLeft = 5000;
      sunLight.shadowCameraRight = -5000;
      sunLight.shadowCameraTop = 5000;
      sunLight.shadowCameraBottom = -5000;
      this.scene.add(sunLight);
      textureFlare0 = THREE.ImageUtils.loadTexture("textures/lensflare/lensflare0.png");
      textureFlare2 = THREE.ImageUtils.loadTexture("textures/lensflare/lensflare2.png");
      textureFlare3 = THREE.ImageUtils.loadTexture("textures/lensflare/lensflare3.png");
      flareColor = new THREE.Color(0xFFFFFF);
      lensFlare = new THREE.LensFlare(textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor);
      lensFlare.position = sunLight.position;
      lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);
      lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);
      lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);
      lensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending);
      lensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending);
      lensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending);
      lensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending);
      lensFlare.customUpdateCallback = function(object) {
        var flare, vecX, vecY, _i, _len, _ref;
        vecX = -object.positionScreen.x * 2;
        vecY = -object.positionScreen.y * 2;
        _ref = object.lensFlares;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          flare = _ref[_i];
          flare.x = object.positionScreen.x + vecX * flare.distance;
          flare.y = object.positionScreen.y + vecY * flare.distance;
          flare.rotation = 0;
        }
        object.lensFlares[2].y += 0.025;
        return object.lensFlares[3].rotation = object.positionScreen.x * 0.5 + 45 * Math.PI / 180;
      };
      return this.scene.add(lensFlare);
    };

    App.prototype.initSky = function() {
      var cubeShader, format, material, path, urls;
      path = "textures/skybloom/";
      format = '.png';
      urls = [path + 'posx' + format, path + 'negx' + format, path + 'posy' + format, path + 'negy' + format, path + 'negz' + format, path + 'posz' + format];
      this.skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls, null, onload);
      this.skyCubeTexture.format = THREE.RGBFormat;
      cubeShader = THREE.ShaderUtils.lib["cube"];
      cubeShader.uniforms["tCube"].value = this.skyCubeTexture;
      material = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });
      this.skyCube = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), material);
      this.skyCube.name = "skyCube";
      this.scene.add(this.skyCube);
    };

    App.prototype.animate = function() {
      var cameraAbsPos, delta, intersections, pickVector, point, ray, _ref, _ref1, _ref2, _ref3;
      window.requestAnimationFrame(this.animate);
      delta = this.clock.getDelta();
      if ((this.ground != null) && (this.controls != null) && (this.pointer != null)) {
        pickVector = new THREE.Vector3(this.pickMouse.x, this.pickMouse.y, 1);
        this.projector.unprojectVector(pickVector, this.camera);
        cameraAbsPos = this.controls.animationParent.position;
        ray = new THREE.Ray(cameraAbsPos, pickVector.subSelf(cameraAbsPos).normalize());
        intersections = ray.intersectObject(this.ground);
        if (intersections[0]) {
          point = intersections[0].point;
          console.log("" + point.x + " " + point.y + " " + point.z);
          this.pointer.position.set(point.x, point.y + 100, point.z);
        }
      }
      if ((_ref = this.bigWheel) != null) {
        _ref.rotation.y += delta / 10;
      }
      if ((_ref1 = this.carousel) != null) {
        _ref1.rotation.z += delta / 2;
      }
      THREE.AnimationHandler.update(delta);
      if ((_ref2 = this.dcontrols) != null) {
        _ref2.update();
      }
      if ((_ref3 = this.controls) != null) {
        _ref3.update(delta);
      }
      this.render();
      this.stats.update();
    };

    App.prototype.render = function() {
      this.renderer.clear();
      this.composer.render(0.1);
    };

    App.prototype.onWindowResize = function() {
      var _ref;
      this.APP_WIDTH = $(window).width();
      this.APP_HEIGHT = $(window).height();
      this.APP_HALF_X = this.APP_WIDTH / 2;
      this.APP_HALF_Y = this.APP_HEIGHT / 2;
      this.camera.aspect = this.APP_WIDTH / this.APP_HEIGHT;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.APP_WIDTH, this.APP_HEIGHT);
      this.renderTarget = new THREE.WebGLRenderTarget(this.APP_WIDTH, this.APP_HEIGHT);
      this.composer.reset(this.renderTarget);
      if ((_ref = this.controls) != null) {
        _ref.handleResize();
      }
      $("#loading").css({
        'position': 'absolute',
        'width': 400,
        "height": 100,
        'left': this.APP_WIDTH / 2 - 200,
        'top': this.APP_HEIGHT / 2 - 50
      });
    };

    return App;

  })();

  $(function() {
    return $(document).ready(function() {
      if (!Detector.webgl || !Detector.workers) {
        return Detector.addGetWebGLMessage();
      } else {
        return new App;
      }
    });
  });

}).call(this);
