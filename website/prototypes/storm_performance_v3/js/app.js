// Generated by CoffeeScript 1.4.0
(function() {
  var App, ElasticNumber, IFLLoader, IFLPhongFresnelShader, IFLSkyCubeShader, IFLStormParticleShader,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ElasticNumber = (function() {

    function ElasticNumber() {}

    ElasticNumber.prototype.spring = 0.03;

    ElasticNumber.prototype.damping = 0.3;

    ElasticNumber.prototype._value = 0;

    ElasticNumber.prototype._aim = 0;

    ElasticNumber.prototype._vel = 0;

    ElasticNumber.prototype.roundToInt = false;

    ElasticNumber.prototype.maxdelta = 0.5;

    ElasticNumber.prototype.aimAt = function(value) {
      return this._aim = value;
    };

    ElasticNumber.prototype.step = function(delta) {
      var acc, d;
      d = this._aim - this._value;
      acc = d * this.spring - this._vel * this.damping;
      if (this.getDistanceToAim() > .01) {
        this._vel += acc * (Math.min(delta, this.maxdelta) * 100);
        return this._value = this._value + this._vel;
      }
    };

    ElasticNumber.prototype.getDistanceToAim = function() {
      return Math.abs(this._aim - this._value);
    };

    return ElasticNumber;

  })();

  IFLStormParticleShader = (function() {

    function IFLStormParticleShader() {}

    IFLStormParticleShader.prototype.uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib["particle"], THREE.UniformsLib["shadowmap"], THREE.UniformsLib["normalmap"], {
        "envMap": {
          type: "t",
          value: null
        },
        "transparencyMap": {
          type: "t",
          value: null
        },
        "alpha": {
          type: "f",
          value: 0.1
        }
      }
    ]);

    IFLStormParticleShader.prototype.vertexShader = ["uniform float size;", "uniform float scale;", "uniform float alpha;", "uniform sampler2D transparencyMap;", "varying vec3 vWorldPosition;", "varying vec3 vReflect;", "varying vec3 vNWorld;", "varying vec3 vNormal;", THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vWorldPosition = position.xyz;", "#ifdef USE_SIZEATTENUATION", "gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "#else", "gl_PointSize = size;", "#endif", "gl_Position = projectionMatrix * mvPosition;", "vNormal = mvPosition.xyz;", "vNWorld = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * vNormal;", "vReflect = reflect( normalize( position.xyz - cameraPosition ), normalize( vNWorld.xyz ) );", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n");

    IFLStormParticleShader.prototype.fragmentShader = ["uniform vec3 psColor;", "uniform float opacity;", "uniform float alpha;", "uniform sampler2D transparencyMap;", "varying vec3 vNWorld;", "varying vec3 vReflect;", "varying vec3 vNormal;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], "#ifdef USE_ENVMAP", "uniform samplerCube envMap;", "#endif", "#ifdef USE_NORMALMAP", "uniform sampler2D normalMap;", "uniform vec2 normalScale;", "#endif", "void main() {", "gl_FragColor = vec4( psColor, opacity );", "#ifdef USE_ENVMAP", "vec3 reflectVec;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "vec3 mapN = texture2D( normalMap, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) ).xyz * 2.0 - 1.0;", "vec3 normal = normalize( mapN );", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "reflectVec = reflect( cameraToVertex, normal );", "#else", "reflectVec = vReflect;", "#endif", "vec4 cubeColor = textureCube( envMap, vec3( -reflectVec.x, reflectVec.yz ) );", "vec4 transColor = texture2D( transparencyMap, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );", "gl_FragColor = vec4( cubeColor.xyz * 2.0 , transColor.r * alpha);", "#endif", THREE.ShaderChunk["alphatest_fragment"], "}"].join("\n");

    return IFLStormParticleShader;

  })();

  IFLSkyCubeShader = (function() {

    IFLSkyCubeShader.prototype.uniforms = null;

    function IFLSkyCubeShader() {
      this.uniforms = {
        "tCube": {
          type: "t",
          value: null
        },
        "tFlip": {
          type: "f",
          value: -1
        }
      };
    }

    IFLSkyCubeShader.prototype.vertexShader = ["varying vec3 vViewPosition;", "void main() {", "vec4 mPosition = modelMatrix * vec4( position, 1.0 );", "vViewPosition = cameraPosition - mPosition.xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n");

    IFLSkyCubeShader.prototype.fragmentShader = ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vViewPosition;", "void main() {", "vec3 wPos = cameraPosition - vViewPosition;", "gl_FragColor = textureCube( tCube, vec3( tFlip * wPos.x, wPos.yz ) );", "}"].join("\n");

    return IFLSkyCubeShader;

  })();

  IFLPhongFresnelShader = (function() {

    function IFLPhongFresnelShader() {}

    IFLPhongFresnelShader.prototype.uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"], {
        "ambient": {
          type: "c",
          value: new THREE.Color(0xffffff)
        },
        "emissive": {
          type: "c",
          value: new THREE.Color(0x000000)
        },
        "specular": {
          type: "c",
          value: new THREE.Color(0x111111)
        },
        "shininess": {
          type: "f",
          value: 30
        },
        "wrapRGB": {
          type: "v3",
          value: new THREE.Vector3(1, 1, 1)
        },
        "tAux": {
          type: "t",
          value: null
        },
        "mFresnelBias": {
          type: "f",
          value: 0
        },
        "mFresnelGain": {
          type: "f",
          value: 1
        },
        "mFresnelPower": {
          type: "f",
          value: 0.0
        }
      }
    ]);

    IFLPhongFresnelShader.prototype.vertexShader = ["#define PHONG", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "varying vec3 vNWorld;", "varying vec3 vI;", THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], "varying vec3 vReflect;", "uniform float refractionRatio;", "uniform bool useRefract;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "vNormal = objectNormal;", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], "vec4 mvPosition;", "mvPosition = modelViewMatrix * vec4( position, 1.0 );", "gl_Position = projectionMatrix * mvPosition;", "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], "#if defined( USE_ENVMAP )", "vNWorld = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;", "vI = normalize( mPosition.xyz - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( vI, normalize( vNWorld.xyz ), refractionRatio );", "} else {", "vReflect = reflect( vI, normalize( vNWorld.xyz ) );", "}", "#endif", "vWorldPosition = mPosition.xyz;", "}"].join("\n");

    IFLPhongFresnelShader.prototype.fragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 ambient;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform sampler2D tAux;", "uniform float mFresnelBias;", "uniform float mFresnelGain;", "uniform float mFresnelPower;", "varying vec3 vNWorld;", "varying vec3 vI;", THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], "#ifdef USE_ENVMAP", "varying vec3 vReflect;", "uniform float reflectivity;", "uniform samplerCube envMap;", "uniform float flipEnvMap;", "uniform int combine;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "uniform bool useRefract;", "uniform float refractionRatio;", "#endif", "#endif", THREE.ShaderChunk["fog_pars_fragment"], "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", THREE.ShaderChunk["shadowmap_pars_fragment"], "#ifdef USE_NORMALMAP", "uniform sampler2D normalMap;", "uniform vec2 normalScale;", "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {", "vec3 q0 = dFdx( eye_pos.xyz );", "vec3 q1 = dFdy( eye_pos.xyz );", "vec2 st0 = dFdx( vUv.st );", "vec2 st1 = dFdy( vUv.st );", "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );", "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );", "vec3 N = normalize( surf_norm );", "vec3 nmap = texture2D( normalMap, vUv ).xyz;", "nmap.y = 1.0 - nmap.y;", "vec3 mapN = nmap * 2.0 - 1.0;", "mapN.xy = normalScale * mapN.xy;", "mat3 tsn = mat3( S, T, N );", "return normalize( tsn * mapN );", "}", "#endif", THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );", "#ifdef USE_MAP", "#ifdef GAMMA_INPUT", "vec4 texelColor = texture2D( map, vUv );", "texelColor.xyz *= texelColor.xyz;", "gl_FragColor = gl_FragColor * texelColor;", "#else", "gl_FragColor = gl_FragColor * texture2D( map, vUv );", "gl_FragColor.xyz *= 1.5;", "#endif", "#endif", THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "vec3 viewPosition = normalize( vViewPosition );", "vec3 normal = normalize( vNormal );", "#ifdef USE_ENVMAP", "vec3 reflectVec;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "normal = perturbNormal2Arb( -viewPosition, normal );", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "reflectVec = refract( cameraToVertex, normal, refractionRatio );", "} else { ", "reflectVec = reflect( cameraToVertex, normal );", "}", "#else", "reflectVec = vReflect;", "#endif", "#ifdef DOUBLE_SIDED", "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#else", "vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#endif", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#else", "cubeColor.xyz *= 2.0;", "#endif", "gl_FragColor = vec4(cubeColor.xyz,gl_FragColor.w * 0.2);", "#endif", "#ifdef GAMMA_OUTPUT", "float d = 1.0/1.8;", "gl_FragColor.rgb = pow( gl_FragColor.rgb , vec3(d,d,d) );", "#endif", THREE.ShaderChunk["fog_fragment"], "}"].join("\n");

    return IFLPhongFresnelShader;

  })();

  IFLLoader = (function() {

    IFLLoader.prototype.IFLVertexAttribute = {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    };

    IFLLoader.prototype.library = null;

    IFLLoader.prototype.callback = null;

    IFLLoader.prototype.callbackProgress = null;

    IFLLoader.prototype.worker = null;

    IFLLoader.prototype.convertTextureIndex = 0;

    IFLLoader.prototype.t = 0;

    IFLLoader.prototype.url = null;

    IFLLoader.prototype.loadingPhase = 0;

    IFLLoader.prototype.totalLoadingPhases = 4;

    IFLLoader.prototype.sky = null;

    IFLLoader.prototype.customMaterialInstancer = null;

    IFLLoader.prototype.enableMaterialCache = true;

    IFLLoader.prototype.matCache = null;

    IFLLoader.prototype.enableTextureCache = true;

    IFLLoader.prototype.texCache = null;

    function IFLLoader() {
      this.doParseLibrary = __bind(this.doParseLibrary, this);

      this.onXHRReadyStatusChange = __bind(this.onXHRReadyStatusChange, this);

      this.onXHRProgress = __bind(this.onXHRProgress, this);

      this.onWorkerMessage = __bind(this.onWorkerMessage, this);
      this.texCache = {};
      this.matCache = {};
    }

    IFLLoader.prototype.initWorker = function() {
      this.worker = new Worker('/js/workers/iflworker.js');
      return this.worker.onmessage = this.onWorkerMessage;
    };

    IFLLoader.prototype.onWorkerMessage = function(event) {
      var loaded, subtype, total;
      switch (event.data.type) {
        case "console":
          return console[event.data.action](event.data.msg);
        case "progress":
          loaded = event.data.data.progress;
          total = event.data.data.total;
          subtype = event.data.subtype;
          return this.handleProgress(loaded, total);
        default:
          return this[event.data.callback](event.data.data);
      }
    };

    IFLLoader.prototype.handleProgress = function(loaded, total) {
      var currentUnitBase, currentUnitProgress, totalLoaded, unit;
      if (this.callbackProgress != null) {
        unit = 100 / this.totalLoadingPhases;
        currentUnitBase = unit * this.loadingPhase;
        currentUnitProgress = (loaded * unit) / total;
        totalLoaded = currentUnitBase + currentUnitProgress;
        return this.callbackProgress(totalLoaded, 100);
      }
    };

    IFLLoader.prototype.load = function(url, callback, callbackProgress) {
      this.loadingPhase = 0;
      this.url = url;
      this.callback = callback;
      this.callbackProgress = callbackProgress;
      this.xhr = new XMLHttpRequest();
      this.xhr.onreadystatechange = this.onXHRReadyStatusChange;
      this.xhr.onprogress = this.onXHRProgress;
      this.xhr.open("GET", url, true);
      this.xhr.responseType = "arraybuffer";
      return this.xhr.send(null);
    };

    IFLLoader.prototype.onXHRProgress = function(event) {
      return this.handleProgress(event.loaded, event.total);
    };

    IFLLoader.prototype.onXHRReadyStatusChange = function() {
      var response, _ref;
      if (this.xhr.readyState === this.xhr.DONE) {
        if (this.xhr.status === 200 || this.xhr.status === 0) {
          response = (_ref = this.xhr.response) != null ? _ref : this.xhr.mozResponseArrayBuffer;
          this.decompressLibrary(response);
        } else {
          console.error("[ IFLLoader ]: Couldn't load [ " + url + " ] [ " + this.xhr.status + " ]");
        }
      }
    };

    IFLLoader.prototype.decompressLibrary = function(data) {
      if (!(data != null) || data.length === 0) {
        throw "Error Loading File, length is 0";
      }
      this.t = new Date().getTime();
      this.loadingPhase++;
      this.initWorker();
      return this.worker.postMessage({
        type: "inflate",
        data: data,
        callback: "parseLibrary"
      });
    };

    IFLLoader.prototype.parseLibrary = function(data) {
      var time;
      if (!(data != null) || data.length === 0) {
        throw "Error Decompressing Library, length is 0";
      }
      time = (new Date().getTime() - this.t) / 1000;
      console.log("[" + this.url + "] decompression time: " + time + " , raw data length: " + data.length);
      this.loadingPhase++;
      this.t = new Date().getTime();
      this.worker.postMessage({
        type: "kill"
      });
      this.initWorker();
      this.rawData = data;
      return setTimeout(this.doParseLibrary, 1000);
    };

    IFLLoader.prototype.doParseLibrary = function() {
      return this.worker.postMessage({
        type: "convert_library",
        data: this.rawData,
        callback: "onLibraryParsed"
      });
    };

    IFLLoader.prototype.onLibraryParsed = function(data) {
      var content, func, time, _i, _len, _ref;
      if (!(data != null)) {
        "Error Parsing library, is null";

      }
      this.library = data;
      time = (new Date().getTime() - this.t) / 1000;
      console.log("[" + this.url + "] Library Parse time: " + time);
      for (func in this.IFLLibraryFuncs) {
        this.library[func] = this.IFLLibraryFuncs[func];
      }
      this.library._contentByID = {};
      _ref = this.library._content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        content = _ref[_i];
        this.library._contentByID[content._reference.id] = content;
      }
      this.t = new Date().getTime();
      this.loadingPhase++;
      this.worker.postMessage({
        type: "kill"
      });
      this.initWorker();
      return this.convertTextures();
    };

    IFLLoader.prototype.convertTextures = function() {
      var bmp, i, _i, _ref, _ref1;
      for (i = _i = _ref = this.convertTextureIndex, _ref1 = this.library._content.length; _i < _ref1; i = _i += 1) {
        if (this.library._content[i].iflType === "IFLBitmap") {
          bmp = this.library._content[i];
          this.convertTextureIndex = i + 1;
          if (bmp._hasOriginalByteArray) {
            this.worker.postMessage({
              type: "parse_jpg",
              image: bmp._savedBytes,
              w: bmp._width,
              h: bmp._height,
              callback: "onTextureConverted"
            });
          } else {
            this.worker.postMessage({
              type: "convert_argb",
              image: bmp._savedBytes,
              w: bmp._width,
              h: bmp._height,
              callback: "onTextureConverted"
            });
          }
          return;
        }
        this.handleProgress(i, this.library._content.length);
      }
      return this.createModel();
    };

    IFLLoader.prototype.onTextureConverted = function(data) {
      var bmp;
      bmp = this.library._content[this.convertTextureIndex - 1];
      if (!(data != null)) {
        throw "Bitmap " + bmp._reference.id + " contains invalid data";
      }
      bmp.converted = data;
      return this.convertTextures();
    };

    IFLLoader.prototype.createModel = function() {
      var root, rootObject, rootObjects, _i, _len;
      console.log(("[" + this.url + "] convert textures time: ") + (new Date().getTime() - this.t) / 1000);
      this.t = new Date().getTime();
      root = new THREE.Object3D();
      rootObjects = this.library.getRootNodes();
      for (_i = 0, _len = rootObjects.length; _i < _len; _i++) {
        rootObject = rootObjects[_i];
        root.add(this.convertNode(rootObject));
      }
      console.log(("[" + this.url + "] convert node time: ") + (new Date().getTime() - this.t) / 1000);
      this.callback(root);
      this.worker.postMessage({
        type: "kill"
      });
    };

    IFLLoader.prototype.convertNode = function(iflnode) {
      var child, childID, mat, retEntity, _i, _len, _ref;
      switch (iflnode.iflType) {
        case "IFLMesh":
          retEntity = this.convertMesh(iflnode);
          break;
        default:
          retEntity = new THREE.Object3D();
      }
      retEntity.name = iflnode._reference.id;
      retEntity.matrix = this.convertMatrix4(iflnode._transformMatrix);
      retEntity.scale.getScaleFromMatrix(retEntity.matrix);
      mat = new THREE.Matrix4().extractRotation(retEntity.matrix);
      retEntity.rotation.setEulerFromRotationMatrix(retEntity.matrix, retEntity.eulerOrder);
      retEntity.position.getPositionFromMatrix(retEntity.matrix);
      _ref = iflnode.childIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childID = _ref[_i];
        child = this.library.getContent(childID.id);
        if (child) {
          retEntity.add(this.convertNode(child));
        }
      }
      return retEntity;
    };

    IFLLoader.prototype.convertMatrix4 = function(m) {
      return new THREE.Matrix4(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
    };

    IFLLoader.prototype.convertMesh = function(iflmesh) {
      var bone, color_length, colors, geometry, index, isSkinnedMesh, material, normals, positions, ret, skinIndices, skinWeights, tangents, uvs, _i, _len, _ref;
      positions = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.POSITION];
      uvs = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.UV];
      if (!(uvs != null)) {
        console.warn("Mesh " + iflmesh._reference.id + " has no UVs");
      }
      normals = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.NORMALS];
      if (!(normals != null)) {
        console.warn("Mesh " + iflmesh._reference.id + " has no Normals");
      }
      tangents = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.TEX_TANGENTS];
      colors = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.COLOR];
      color_length = 0;
      if (colors != null) {
        color_length = iflmesh.verticesDecomposed._vertexAttributeLengths[this.IFLVertexAttribute.COLOR];
      }
      skinWeights = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.JOINT_WEIGHTS];
      skinIndices = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.JOINT_INDICES];
      isSkinnedMesh = skinWeights && skinIndices;
      geometry = this.convertGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
      geometry.hasTangents = tangents != null;
      material = iflmesh.subMeshes.length === 1 ? geometry.materials[0] : new THREE.MeshFaceMaterial;
      material.skinning = isSkinnedMesh;
      if (isSkinnedMesh) {
        ret = new THREE.SkinnedMesh(geometry, material);
      } else {
        ret = new THREE.Mesh(geometry, material);
      }
      if (isSkinnedMesh) {
        _ref = ret.geometry.bones;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          bone = _ref[index];
          ret.boneInverses[index] = bone.invBindMatrix;
        }
      }
      ret.castShadow = ret.receiveShadow = true;
      return ret;
    };

    IFLLoader.prototype.convertBufferGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
      var geometry, indexBuffer;
      geometry = new THREE.BufferGeometry;
      indexBuffer = iflmesh.subMeshes[0].indexBuffer._rawData;
      geometry.attributes = {};
      geometry.attributes.index = {
        itemSize: 1,
        array: new Int16Array(indexBuffer.length),
        numItems: indexBuffer.length
      };
      geometry.attributes.index.array.set(indexBuffer);
      geometry.attributes.position = {
        itemSize: 3,
        array: positions,
        numItems: positions.length
      };
      if (uvs) {
        geometry.attributes.uv = {
          itemSize: 2,
          array: uvs,
          numItems: uvs.length
        };
      }
      if (normals) {
        geometry.attributes.normal = {
          itemSize: 3,
          array: normals,
          numItems: normals.length
        };
      }
      if (tangents) {
        geometry.attributes.tangent = {
          itemSize: 3,
          array: tangents,
          numItems: tangents.length
        };
      }
      geometry.offsets = [
        {
          start: 0,
          count: indexBuffer.length,
          index: 0
        }
      ];
      geometry.materials = [this.convertMaterial(iflmesh.subMeshes[0], iflmesh._reference.id)];
      return geometry;
    };

    IFLLoader.prototype.convertGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
      var cachedColors, cachedNormals, cachedPositions, cachedTangents, cachedUVs, face, faceIndex, fakeUV, fvUVs, geometry, i, i1, i12, i13, i14, i2, i22, i23, i24, i3, i32, i33, i34, ib, ibi, material, p1, p2, p3, positionRearrangment, reasons, second, stepSize, subMesh, subMeshIndex, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _step;
      reasons = "";
      if (positions.length >= 65535) {
        reasons += "[Vertices > 65535]";
      }
      if (isSkinnedMesh) {
        reasons += "[Is Skinned Mesh]";
      }
      if (iflmesh.subMeshes.length > 1) {
        reasons += "[Has Submeshes]";
      }
      if (colors != null) {
        reasons += "[Has Vertex Colors]";
      }
      geometry = new THREE.Geometry;
      cachedUVs = [];
      cachedNormals = [];
      cachedTangents = [];
      cachedColors = [];
      cachedPositions = {};
      positionRearrangment = {};
      if (positions) {
        for (i = _i = 0, _ref = positions.length; _i < _ref; i = _i += 3) {
          p1 = positions[i];
          p2 = positions[i + 1];
          p3 = positions[i + 2];
          if (!cachedPositions[p1 + "_" + p2 + "_" + p3]) {
            cachedPositions[p1 + "_" + p2 + "_" + p3] = {
              index: geometry.vertices.length,
              vertex: new THREE.Vector3(p1, p2, p3)
            };
            geometry.vertices.push(cachedPositions[p1 + "_" + p2 + "_" + p3].vertex);
          }
          positionRearrangment[i / 3] = cachedPositions[p1 + "_" + p2 + "_" + p3].index;
        }
      } else {
        return new THREE.Object3D();
      }
      if (isSkinnedMesh) {
        stepSize = iflmesh.verticesDecomposed._vertexAttributeLengths[this.IFLVertexAttribute.JOINT_INDICES];
        if (stepSize <= 2) {
          for (i = _j = 0, _ref1 = skinIndices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += stepSize) {
            second = Math.floor(i + stepSize / 2);
            geometry.skinWeights.push(new THREE.Vector4(skinWeights[i], skinWeights[second], 0, 0));
            geometry.skinIndices.push(new THREE.Vector4(skinIndices[i], skinIndices[second], 0, 0));
          }
        }
        geometry.bones = this.convertBones(iflmesh);
        geometry.animation = this.convertAnimations(geometry.bones, iflmesh);
      }
      fakeUV = new THREE.UV(0, 0);
      _ref2 = iflmesh.subMeshes;
      for (subMeshIndex = _k = 0, _len = _ref2.length; _k < _len; subMeshIndex = ++_k) {
        subMesh = _ref2[subMeshIndex];
        material = this.convertMaterial(subMesh, iflmesh._reference.id);
        material.skinning = isSkinnedMesh;
        geometry.materials.push(material);
        ib = subMesh.indexBuffer._rawData;
        for (ibi = _l = 0, _len1 = ib.length, _step = 3; _l < _len1; ibi = _l += _step) {
          i1 = ib[ibi];
          i2 = ib[ibi + 1];
          i3 = ib[ibi + 2];
          i12 = i1 * 2;
          i22 = i2 * 2;
          i32 = i3 * 2;
          i13 = i1 * 3;
          i23 = i2 * 3;
          i33 = i3 * 3;
          i14 = i1 * 4;
          i24 = i2 * 4;
          i34 = i3 * 4;
          face = new THREE.Face3(positionRearrangment[i1], positionRearrangment[i2], positionRearrangment[i3], null, null, subMeshIndex);
          faceIndex = geometry.faces.length;
          fvUVs = geometry.faceVertexUvs[0][faceIndex] = [];
          if (uvs != null) {
            fvUVs.push(cachedUVs[i12] ? cachedUVs[i12] : cachedUVs[i12] = new THREE.UV(uvs[i12], uvs[i12 + 1]));
            fvUVs.push(cachedUVs[i22] ? cachedUVs[i22] : cachedUVs[i22] = new THREE.UV(uvs[i22], uvs[i22 + 1]));
            fvUVs.push(cachedUVs[i32] ? cachedUVs[i32] : cachedUVs[i32] = new THREE.UV(uvs[i32], uvs[i32 + 1]));
          } else {
            fvUVs.push(fakeUV);
            fvUVs.push(fakeUV);
            fvUVs.push(fakeUV);
          }
          if (normals != null) {
            face.vertexNormals.push(cachedNormals[i13] ? cachedNormals[i13] : cachedNormals[i13] = new THREE.Vector3(normals[i13], normals[i13 + 1], normals[i13 + 2]));
            face.vertexNormals.push(cachedNormals[i23] ? cachedNormals[i23] : cachedNormals[i23] = new THREE.Vector3(normals[i23], normals[i23 + 1], normals[i23 + 2]));
            face.vertexNormals.push(cachedNormals[i33] ? cachedNormals[i33] : cachedNormals[i33] = new THREE.Vector3(normals[i33], normals[i33 + 1], normals[i33 + 2]));
          }
          if (tangents != null) {
            face.vertexTangents.push(cachedTangents[i13] ? cachedTangents[i13] : cachedTangents[i13] = new THREE.Vector4(tangents[i13], tangents[i13 + 1], tangents[i13 + 2], 1));
            face.vertexTangents.push(cachedTangents[i23] ? cachedTangents[i23] : cachedTangents[i23] = new THREE.Vector4(tangents[i23], tangents[i23 + 1], tangents[i23 + 2], 1));
            face.vertexTangents.push(cachedTangents[i33] ? cachedTangents[i33] : cachedTangents[i33] = new THREE.Vector4(tangents[i33], tangents[i33 + 1], tangents[i33 + 2], 1));
          }
          if (colors != null) {
            if (color_length === 3) {
              face.vertexColors.push(cachedColors[i13] ? cachedColors[i13] : cachedColors[i13] = new THREE.Color().setRGB(colors[i13], colors[i13 + 1], colors[i13 + 2]));
              face.vertexColors.push(cachedColors[i23] ? cachedColors[i23] : cachedColors[i23] = new THREE.Color().setRGB(colors[i23], colors[i23 + 1], colors[i23 + 2]));
              face.vertexColors.push(cachedColors[i33] ? cachedColors[i33] : cachedColors[i33] = new THREE.Color().setRGB(colors[i33], colors[i33 + 1], colors[i33 + 2]));
            }
            if (color_length === 4) {
              face.vertexColors.push(cachedColors[i14] ? cachedColors[i14] : cachedColors[i14] = new THREE.Color().setRGB(colors[i14], colors[i14 + 1], colors[i14 + 2]));
              face.vertexColors.push(cachedColors[i24] ? cachedColors[i24] : cachedColors[i24] = new THREE.Color().setRGB(colors[i24], colors[i24 + 1], colors[i24 + 2]));
              face.vertexColors.push(cachedColors[i34] ? cachedColors[i34] : cachedColors[i34] = new THREE.Color().setRGB(colors[i34], colors[i34 + 1], colors[i34 + 2]));
            }
          }
          geometry.faces.push(face);
        }
      }
      try {
        geometry.computeCentroids();
      } catch (e) {
        console.warn("error computing centroids for " + iflmesh._reference.id);
      }
      try {
        geometry.computeFaceNormals();
      } catch (e) {
        console.warn("error computing face normals for " + iflmesh._reference.id);
      }
      try {
        geometry.computeTangents();
      } catch (e) {
        console.warn("error computing tangents for " + iflmesh._reference.id);
      }
      return geometry;
    };

    IFLLoader.prototype.convertBones = function(iflmesh) {
      var bind, bindingToJoint, bindings, bindpose, decomp, i, iflparent, invBindMatrix, jo, joint, jointMatrix, jointToBinding, jointToIndex, joints, p, parent, pos, root, rotq, scale, sk, skeletonJoint, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      joints = [];
      jointToBinding = [];
      bindingToJoint = [];
      bindings = iflmesh.jointBindings;
      for (i = _i = 0, _ref = bindings.length; _i < _ref; i = _i += 1) {
        jo = this.library.getContent(bindings[i].jointID.id);
        if (!(jo != null)) {
          return null;
        }
        jointToBinding[jo._reference.id] = i;
        bindingToJoint[i] = jo._reference.id;
        joints.push(jo);
      }
      for (_j = 0, _len = joints.length; _j < _len; _j++) {
        joint = joints[_j];
        if (!this.library.findJointParent(joint)) {
          root = joint;
          break;
        }
      }
      bindpose = this.convertMatrix4(iflmesh.bindPoseMatrix);
      sk = [];
      sk.name = root.id;
      jointToIndex = [];
      skeletonJoint;

      for (i = _k = 0, _ref1 = bindings.length; _k < _ref1; i = _k += 1) {
        skeletonJoint = {};
        skeletonJoint.name = joints[i]._reference.id;
        jointMatrix = this.convertMatrix4(joints[i]._transformMatrix);
        invBindMatrix = this.convertMatrix4(bindings[i].inverseBindMatrix);
        decomp = jointMatrix.decompose();
        skeletonJoint.pos = [decomp[0].x, decomp[0].y, decomp[0].z];
        skeletonJoint.rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
        jointToIndex[skeletonJoint.name] = sk.length;
        skeletonJoint.invBindMatrix = invBindMatrix;
        skeletonJoint.jointMatrix = jointMatrix;
        sk.push(skeletonJoint);
      }
      for (i = _l = 0, _ref2 = bindings.length; _l < _ref2; i = _l += 1) {
        skeletonJoint = sk[i];
        parent = this.library.findJointParent(joints[i]);
        if (!(parent != null)) {
          skeletonJoint.parent = -1;
        } else {
          if (parent.iflType === "IFLJoint") {
            if (jointToIndex[parent._reference.id] !== void 0) {
              skeletonJoint.parent = jointToIndex[parent._reference.id];
            } else {
              skeletonJoint.parent = -1;
            }
          } else {
            skeletonJoint.parent = -1;
          }
        }
      }
      for (i = _m = 0, _ref3 = bindings.length; _m < _ref3; i = _m += 1) {
        skeletonJoint = sk[i];
        bind = skeletonJoint.invBindMatrix.clone();
        scale = this.setScale1(bind);
        bind.getInverse(bind);
        if (i !== 0) {
          p = sk[skeletonJoint.parent];
          bind.multiply(p.invBindMatrix, bind);
          iflparent = this.library.findParent(this.library.getContent(skeletonJoint.name));
          if (iflparent.iflType !== "IFLJoint") {
            this.prependNonJointParents(bind, iflparent);
          }
        } else {
          bind.multiply(bindpose, bind);
        }
        decomp = bind.decompose();
        pos = [decomp[0].x, decomp[0].y, decomp[0].z];
        rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
        skeletonJoint.pos = pos;
        skeletonJoint.rotq = rotq;
      }
      return sk;
    };

    IFLLoader.prototype.prependNonJointParents = function(bind, iflparent) {
      var otherparent, parentmat, prepended;
      parentmat = this.convertMatrix4(iflparent._transformMatrix);
      prepended = new THREE.Matrix4().multiply(parentmat, bind);
      bind.copy(prepended);
      otherparent = this.library.findParent(iflparent);
      if (otherparent.iflType !== "IFLJoint") {
        return this.prependNonJointParents(bind, otherparent);
      }
    };

    IFLLoader.prototype.setScale1 = function(m) {
      var x, y, z;
      x = new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).length();
      y = new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).length();
      z = new THREE.Vector3(m.elements[8], m.elements[9], m.elements[10]).length();
      m.elements[0] /= x;
      m.elements[1] /= x;
      m.elements[2] /= x;
      m.elements[4] /= y;
      m.elements[5] /= y;
      m.elements[6] /= y;
      m.elements[8] /= z;
      m.elements[9] /= z;
      m.elements[10] /= z;
      m.elements[12] /= x;
      m.elements[13] /= y;
      m.elements[14] /= z;
      m.elements[15] = 1;
      return new THREE.Vector3(x, y, z);
    };

    IFLLoader.prototype.findJointParent = function(joint, root) {
      var childID, p, _i, _len, _ref;
      if (!(root != null)) {
        return null;
      }
      _ref = root.childIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childID = _ref[_i];
        if (childID.id === joint._reference.id) {
          return root;
        } else {
          p = findJointParent(joint, this.library.getContent(childID.id));
          if (p) {
            return p;
          }
        }
      }
      return null;
    };

    IFLLoader.prototype.convertAnimations = function(skeleton, iflMesh) {
      var anim, anim3js, anims, bindpose, firstKey, i, j, k, key3js, keys, lastkey, maxTime, numTimes, r, sampler, stillMatDec, stillPos, stillRot, timePerFrame, totalMaxTime, track, track3js, trackLength, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
      anims = this.library.getAnimationsForSkinJoints(iflMesh);
      r = [];
      bindpose = this.convertMatrix4(iflMesh.bindPoseMatrix);
      if (anims.length === 0) {
        anims[0] = {
          _reference: {
            id: "fake"
          },
          tracks: []
        };
      }
      for (i = _i = 0; _i < 1; i = _i += 1) {
        anim3js = {};
        anim3js.name = iflMesh._reference.id + "_" + anims[i]._reference.id;
        anim3js.fps = 30;
        anim3js.hierarchy = [];
        totalMaxTime = 0;
        for (k = _j = 0, _ref = skeleton.length; _j < _ref; k = _j += 1) {
          track = this.getTrackForJoint(skeleton[k], anims[i]);
          stillMatDec = skeleton[k].jointMatrix.decompose();
          maxTime = 0;
          stillPos = skeleton[k].pos;
          stillRot = skeleton[k].rotq;
          if (track != null) {
            track3js = {};
            track3js.parent = skeleton[k].parent;
            track3js.name = "track_" + skeleton[k].name;
            track3js.keys = [];
            sampler = track.sampler;
            trackLength = track.end - track.start;
            numTimes = sampler.times.length;
            timePerFrame = (trackLength / numTimes) * 1000;
            for (j = _k = 0, _ref1 = sampler.times.length; _k < _ref1; j = _k += 1) {
              key3js = {};
              key3js.time = sampler.times[j];
              maxTime = Math.max(key3js.time, maxTime);
              totalMaxTime = Math.max(maxTime, totalMaxTime);
              key3js.pos = [sampler.positions[j].x, sampler.positions[j].y, sampler.positions[j].z];
              key3js.rot = [sampler.orientations[j].x, sampler.orientations[j].y, sampler.orientations[j].z, sampler.orientations[j].w];
              key3js.scl = [1, 1, 1];
              track3js.keys.push(key3js);
            }
          } else {
            console.log("no track for joint " + skeleton[k].name + " creating a fake one");
            anim = anims[i];
            sampler = anim.tracks.length > 0 ? anim.tracks[0].sampler : {
              times: [0, 1]
            };
            track3js = {};
            track3js.name = "fake_track_" + skeleton[k].name;
            track3js.parent = skeleton[k].parent;
            track3js.keys = [];
            for (j = _l = 0, _ref2 = sampler.times.length; _l < _ref2; j = _l += 1) {
              key3js = {};
              key3js.time = sampler.times[j];
              maxTime = Math.max(key3js.time, maxTime);
              totalMaxTime = Math.max(maxTime, totalMaxTime);
              key3js.pos = [stillPos[0], stillPos[1], stillPos[2]];
              key3js.rot = [stillRot[0], stillRot[1], stillRot[2], stillRot[3]];
              key3js.scl = [1, 1, 1];
              track3js.keys.push(key3js);
            }
          }
          anim3js.length = maxTime;
          anim3js.hierarchy.push(track3js);
        }
        for (k = _m = 0, _ref3 = anim3js.hierarchy.length; _m < _ref3; k = _m += 1) {
          keys = anim3js.hierarchy[k].keys;
          lastkey = keys[keys.length - 1];
          firstKey = keys[0];
          if (lastkey.time < totalMaxTime) {
            keys.push({
              time: totalMaxTime,
              pos: lastkey.pos,
              rot: lastkey.rot,
              scl: lastkey.scl
            });
          }
          if (firstKey.time > 0) {
            keys.unshift({
              time: 0,
              pos: firstKey.pos,
              rot: firstKey.rot,
              scl: firstKey.scl
            });
          }
        }
        anim3js.length = totalMaxTime;
        r.push(anim3js);
      }
      return r[0];
    };

    IFLLoader.prototype.getTrackForJoint = function(joint, anim) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = anim.tracks.length; _i < _ref; i = _i += 1) {
        if (anim.tracks[i].target.id === joint.name) {
          return anim.tracks[i];
        }
      }
      return null;
    };

    IFLLoader.prototype.convertMaterial = function(subMesh, meshname) {
      var instanced, matid;
      matid = subMesh.material._reference.id;
      if (!this.matCache[matid] || !this.enableMaterialCache) {
        if (this.customMaterialInstancer != null) {
          instanced = this.customMaterialInstancer.apply(this, [subMesh, meshname]);
          if (instanced != null) {
            this.matCache[matid] = instanced;
          } else {
            this.matCache[matid] = this.convertGenericMaterial(subMesh);
          }
        } else {
          this.matCache[matid] = this.convertGenericMaterial(subMesh);
        }
      }
      return this.matCache[matid];
    };

    IFLLoader.prototype.getMaterialParams = function(subMesh) {
      var params;
      params = {
        color: subMesh.material.diffuse.uintValue,
        ambient: subMesh.material.ambient.uintValue,
        specular: subMesh.material.specular.uintValue,
        map: this.getSubmeshTexture(subMesh.diffuseTextures),
        normalMap: this.getSubmeshTexture(subMesh.normalTextures),
        specularMap: this.getSubmeshTexture(subMesh.specularTextures),
        lightMap: null,
        bumpMap: null,
        reflectivity: subMesh.material.reflectivity,
        shininess: subMesh.material.shininess,
        opacity: subMesh.material.transparency !== 0 && subMesh.material.transparency !== 1 ? 1 - subMesh.material.transparency : 1
      };
      return params;
    };

    IFLLoader.prototype.convertGenericMaterial = function(subMesh) {
      var mat, params;
      params = this.getMaterialParams(subMesh);
      mat = new THREE.MeshLambertMaterial(params);
      if (params.map) {
        mat.transparent = params.map.transparent;
      }
      return mat;
    };

    IFLLoader.prototype.getSubmeshTexture = function(from) {
      if (from.length > 0) {
        return this.getTexture(from[0].id, false);
      }
      return null;
    };

    IFLLoader.prototype.getTexture = function(id) {
      var ret, tex;
      tex = this.library.getContent(id);
      if (!(tex != null)) {
        console.warn("[" + this.url + "] Texture " + id + " not found");
        return null;
      }
      if (tex.converted != null) {
        if (!(this.texCache[tex._reference.id] != null) || !this.enableTextureCache) {
          this.texCache[tex._reference.id] = ret = new THREE.DataTexture(tex.converted, tex._width, tex._height, tex._hasOriginalByteArray ? THREE.RGBFormat : THREE.RGBAFormat);
        } else {
          ret = this.texCache[tex._reference.id];
        }
      } else {
        console.warn("[" + this.url + "] Texture " + id + " was not converted");
      }
      if (ret) {
        ret.needsUpdate = true;
        ret.flipY = false;
        ret.transparent = tex.transparent;
      }
      return ret;
    };

    IFLLoader.prototype.getCubeTexture = function(array) {
      var image, images, index, path, tex, texture, _i, _len;
      images = [];
      texture = new THREE.Texture();
      texture.image = images;
      texture.flipY = false;
      for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
        path = array[index];
        tex = this.getTexture(path);
        image = tex.image;
        image.format = tex.format;
        images[index] = image;
      }
      texture.needsUpdate = true;
      return texture;
    };

    IFLLoader.prototype.dispose = function() {
      var _ref, _ref1, _ref2;
      if ((_ref = this.worker) != null) {
        _ref.onmessage = function() {
          return console.log("[" + this.url + "] Message aborted");
        };
      }
      try {
        if ((_ref1 = this.xhr) != null) {
          _ref1.abort();
        }
      } catch (_error) {}
      try {
        if ((_ref2 = this.worker) != null) {
          _ref2.terminate();
        }
      } catch (_error) {}
      this.matCache = null;
      this.texCache = null;
      this.customMaterialInstancer = null;
      this.library = null;
      this.callback = null;
      return this.callbackProgress = null;
    };

    IFLLoader.prototype.IFLLibraryFuncs = {
      getContent: function(id) {
        return this._contentByID[id];
      },
      getRootNodes: function() {
        return this.getRootNodesIn(this._content);
      },
      isIFLNode: function(object) {
        return object.iflType === "IFLNode" || object.iflType === "IFLJoint" || object.iflType === "IFLMesh" || object.iflType === "IFLMeshContainer" || object.iflType === "IFLLight" || object.iflType === "IFLCamera";
      },
      getDiffuseTexture: function(subMesh) {
        return this.getContent(subMesh._diffuseTextures[0].id);
      },
      getRootNodesIn: function(lib) {
        var k, m, meshesChildrenOfSomeone, meshesNotChildrenOfSomeone, tm, _i, _j, _len, _len1, _ref;
        meshesChildrenOfSomeone = [];
        meshesNotChildrenOfSomeone = [];
        for (_i = 0, _len = lib.length; _i < _len; _i++) {
          tm = lib[_i];
          if (!(this.isIFLNode(tm))) {
            continue;
          }
          if (meshesChildrenOfSomeone.indexOf(tm._reference.id) === -1) {
            meshesNotChildrenOfSomeone.push(tm._reference.id);
          }
          _ref = tm.childIDs;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            m = _ref[_j];
            if (meshesNotChildrenOfSomeone.indexOf(m.id) !== -1) {
              meshesNotChildrenOfSomeone.splice(meshesNotChildrenOfSomeone.indexOf(m.id), 1);
            }
            meshesChildrenOfSomeone.push(m.id);
          }
        }
        return (function() {
          var _k, _ref1, _results;
          _results = [];
          for (k = _k = 0, _ref1 = meshesNotChildrenOfSomeone.length; _k < _ref1; k = _k += 1) {
            _results.push(this.getContent(meshesNotChildrenOfSomeone[k]));
          }
          return _results;
        }).call(this);
      },
      isRoot: function(contentID) {
        return this.isRootWithin(contentID, this._content);
      },
      isRootWithin: function(contentID, context) {
        var childID, content, _i, _j, _len, _len1, _ref;
        for (_i = 0, _len = context.length; _i < _len; _i++) {
          content = context[_i];
          if (this.isIFLNode(content)) {
            _ref = content.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              childID = _ref[_j];
              if (childID.id === contentID) {
                return false;
              }
            }
          }
        }
        return true;
      },
      findParent: function(node, parent) {
        var ch, childID, p, rootNode, rootNodes, _i, _j, _len, _len1, _ref;
        if (!(parent != null)) {
          rootNodes = this.getRootNodes();
          for (_i = 0, _len = rootNodes.length; _i < _len; _i++) {
            rootNode = rootNodes[_i];
            p = this.findParent(node, rootNode);
            if (p != null) {
              return p;
            }
          }
        } else {
          _ref = parent.childIDs;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            childID = _ref[_j];
            if (childID.id === node._reference.id) {
              return parent;
            } else {
              ch = this.getContent(childID.id);
              if (ch) {
                p = this.findParent(node, ch);
                if (p != null) {
                  return p;
                }
              }
            }
          }
        }
        return null;
      },
      getAnimationsForSkinJoints: function(skin) {
        var animRet, doneAnims, jobj, joint, jointAnimation, jointAnimations, r, track, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        r = [];
        doneAnims = [];
        _ref = skin.jointBindings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          jobj = _ref[_i];
          joint = jobj.jointID;
          jointAnimations = this.getAnimationsForID(joint.id, false);
          if ((jointAnimations != null)) {
            for (_j = 0, _len1 = jointAnimations.length; _j < _len1; _j++) {
              jointAnimation = jointAnimations[_j];
              if (!doneAnims[jointAnimation._reference.id]) {
                doneAnims[jointAnimation._reference.id] = {
                  tracks: [],
                  iflType: "IFLAnimation"
                };
                doneAnims[jointAnimation._reference.id]._reference = {
                  id: jointAnimation._reference.id,
                  iflType: "IFLID"
                };
                r.push(doneAnims[jointAnimation._reference.id]);
              }
              animRet = doneAnims[jointAnimation._reference.id];
              _ref1 = jointAnimation.tracks;
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                track = _ref1[_k];
                if (animRet.tracks.indexOf(track) === -1) {
                  animRet.tracks.push(track);
                }
              }
            }
          }
        }
        return r;
      },
      getAnimationsForID: function(id) {
        var animation, r, track, tracks, _i, _j, _len, _len1, _ref;
        r = [];
        _ref = this._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          animation = _ref[_i];
          if (!(animation.iflType === "IFLAnimation")) {
            continue;
          }
          tracks = animation.tracks;
          for (_j = 0, _len1 = tracks.length; _j < _len1; _j++) {
            track = tracks[_j];
            if (track.target.id === id && r.indexOf(animation) === -1) {
              r.push(animation);
            }
          }
        }
        if (r.length > 0) {
          return r;
        }
        return null;
      },
      findJointParent: function(node) {
        var childID, content, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          content = _ref[_i];
          if (this.isIFLNode(content)) {
            _ref1 = content.childIDs;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              childID = _ref1[_j];
              if (childID.id === node._reference.id) {
                if (content.iflType === "IFLJoint") {
                  return content;
                } else {
                  return this.findJointParent(content);
                }
              }
            }
          }
        }
        return null;
      }
    };

    return IFLLoader;

  })();

  App = (function() {

    App.prototype.container = null;

    App.prototype.stats = null;

    App.prototype.camera = null;

    App.prototype.scene = null;

    App.prototype.renderer = null;

    App.prototype.controls = null;

    App.prototype.clock = null;

    App.prototype.loader = null;

    App.prototype.mesh = null;

    App.prototype.particles = null;

    App.prototype.uniforms = null;

    App.prototype.attributes = null;

    App.prototype.numberOfParticles = 100;

    App.prototype.numberOfPlanes = 1;

    App.prototype.particleSize = 5;

    App.prototype.planes = null;

    App.prototype.cameraPositionPoints = [];

    App.prototype.debugPaths = null;

    App.prototype.currentIndex = 0;

    function App() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.instanceBasicMaterial = __bind(this.instanceBasicMaterial, this);

      this.createDebugPath = __bind(this.createDebugPath, this);

      this.onCameraPositionsLoaded = __bind(this.onCameraPositionsLoaded, this);

      this.onComplete = __bind(this.onComplete, this);

      this.onProgress = __bind(this.onProgress, this);

      var ambient;
      this.clock = new THREE.Clock();
      this.container = document.createElement('div');
      document.body.appendChild(this.container);
      this.renderer = new THREE.WebGLRenderer({
        antialias: false,
        clearColor: 0x000000,
        clearAlpha: 1
      });
      this.renderer.gammaInput = false;
      this.renderer.gammaOutput = false;
      this.renderer.sortObjects = false;
      this.renderer.shadowMapEnabled = false;
      this.renderer.shadowMapSoft = true;
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 10, 100000);
      this.camera.position.x = 0;
      this.camera.position.y = 0;
      this.camera.position.z = -1500;
      this.camera.fov = 25;
      this.camera.near = .10;
      this.camera.far = 20000;
      this.camera.target = new THREE.Vector3(0, 0, 0);
      ambient = new THREE.AmbientLight(0xFFFFFF);
      this.scene.add(ambient);
      ambient = new THREE.AmbientLight(0xFFFFFF);
      this.scene.add(ambient);
      this.loader = new IFLLoader();
      this.loader.load("../../models/stormlayers.if3d", this.onComplete, this.onProgress);
      $.ajax({
        url: "/models/storm_position.txt",
        success: this.onCameraPositionsLoaded
      });
      this.container.appendChild(this.renderer.domElement);
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      this.container.appendChild(this.stats.domElement);
      this.initSky();
      this.initSun();
      this.debugPaths = new THREE.Object3D;
      this.scene.add(this.debugPaths);
      this.animate();
      $("body").append("<div id='loading'>Loading Resources<div>");
      $("#loading").append("<div id='progressbar'></div>");
      $("#progressbar").progressbar({
        value: 0
      });
      window.addEventListener('resize', this.onWindowResize, false);
      this.onWindowResize();
      return;
    }

    App.prototype.onProgress = function(loaded, total) {
      return $("#progressbar").progressbar("option", "value", (loaded * 100) / total);
    };

    App.prototype.onComplete = function(iflscene) {
      var descendant, descendants, gui, _i, _len;
      this.scene.add(iflscene);
      this.scene.add(this.skyCube);
      this.scene.add(this.lensFlare);
      descendants = iflscene.getDescendants();
      for (_i = 0, _len = descendants.length; _i < _len; _i++) {
        descendant = descendants[_i];
        if (descendant instanceof THREE.Mesh) {
          descendant.material = this.instanceBasicMaterial();
        }
      }
      this.sph = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({
        color: 0xFF0000,
        wireframe: true
      }));
      this.scene.add(this.sph);
      $("#loading").remove();
      return gui = new dat.GUI;
    };

    App.prototype.onCameraPositionsLoaded = function(data) {
      var arr, posarr, txtpos, _i, _len;
      this.cameraPositionPoints = [];
      arr = data.split("\n");
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        txtpos = arr[_i];
        posarr = txtpos.split(",");
        this.cameraPositionPoints.push([parseFloat(posarr[0]), parseFloat(posarr[1]), parseFloat(posarr[2])]);
      }
      this.createDebugPath(this.cameraPositionPoints);
      this.controls = new THREE.PathControls(this.camera);
      this.controls.waypoints = this.cameraPositionPoints;
      this.controls.duration = 18;
      this.controls.useConstantSpeed = true;
      this.controls.createDebugPath = true;
      this.controls.createDebugDummy = false;
      this.controls.lookSpeed = 0.06;
      this.controls.lookVertical = false;
      this.controls.lookHorizontal = false;
      this.controls.verticalAngleMap = {
        srcRange: [0, 2 * Math.PI],
        dstRange: [1.1, 3.8]
      };
      this.controls.horizontalAngleMap = {
        srcRange: [0, 2 * Math.PI],
        dstRange: [0.3, Math.PI - 0.3]
      };
      this.controls.lon = 360;
      this.controls.init();
      this.scene.add(this.controls.animationParent);
      return this.controls.animation.play(true, 0);
    };

    App.prototype.createDebugPath = function(arr) {
      var dMesh, linegeom, linerenderable, point, root, _i, _len;
      root = new THREE.Object3D;
      linegeom = new THREE.Geometry;
      linerenderable = new THREE.Line(linegeom);
      root.add(linerenderable);
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        point = arr[_i];
        dMesh = new THREE.Mesh(new THREE.SphereGeometry(.1, 3, 2), new THREE.MeshBasicMaterial({
          wireframe: true,
          color: 0xFF0000,
          lights: false
        }));
        dMesh.position.copy(point);
        root.add(dMesh);
        linegeom.vertices.push(point);
      }
      this.debugPaths.add(root);
    };

    App.prototype.instanceBasicMaterial = function() {
      var mat;
      mat = new THREE.MeshPhongMaterial({
        diffuse: 0xFFFFFF,
        ambient: 0x111111
      });
      mat.side = THREE.DoubleSide;
      mat.alphaTest = 0.5;
      mat.opacity = 0.5;
      mat.fog = true;
      mat.lights = true;
      return mat;
    };

    App.prototype.initSky = function() {
      var cubeShader, format, material, path, urls;
      path = "/models/textures/skybloom/";
      format = '.png';
      urls = [path + 'posx' + format, path + 'negx' + format, path + 'posy' + format, path + 'negy' + format, path + 'negz' + format, path + 'posz' + format];
      this.skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls);
      this.skyCubeTexture.format = THREE.RGBFormat;
      cubeShader = new IFLSkyCubeShader;
      cubeShader.uniforms["tCube"].value = this.skyCubeTexture;
      cubeShader.uniforms["tFlip"].value = true;
      material = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });
      this.skyCube = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), material);
      this.skyCube.name = "skyCube";
    };

    App.prototype.initSun = function() {
      var flareColor, sunLight, textureFlare0, textureFlare3,
        _this = this;
      sunLight = new THREE.DirectionalLight();
      sunLight.color.setRGB(1, 1, 1);
      sunLight.position.set(-5000, 1000, -5000);
      sunLight.intensity = 1;
      sunLight.castShadow = true;
      sunLight.shadowCameraNear = 20;
      sunLight.shadowCameraFar = 100000;
      sunLight.shadowCameraFov = 70;
      sunLight.shadowMapWidth = 1024;
      sunLight.shadowMapHeight = 1024;
      sunLight.shadowDarkness = .4;
      sunLight.shadowCameraLeft = 200;
      sunLight.shadowCameraRight = -200;
      sunLight.shadowCameraTop = 100;
      sunLight.shadowCameraBottom = -500;
      sunLight.shadowCameraVisible = true;
      this.scene.add(sunLight);
      this.scene.add(new THREE.AmbientLight(0xffffff));
      textureFlare0 = THREE.ImageUtils.loadTexture("/models/textures/lensflare/lensflare0.png");
      textureFlare3 = THREE.ImageUtils.loadTexture("/models/textures/lensflare/hexangle.png");
      flareColor = new THREE.Color(0xFFFFFF);
      this.lensFlare = new THREE.LensFlare(textureFlare0, 1000, 0.0, THREE.AdditiveBlending, flareColor);
      this.lensFlare.position.set(-2000, 500, -2000);
      this.lensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending);
      this.lensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending);
      this.lensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending);
      this.lensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending);
      this.lensFlare.customUpdateCallback = function(object) {
        var flare, vecX, vecY, _i, _len, _ref;
        vecX = -object.positionScreen.x * 2;
        vecY = -object.positionScreen.y * 2;
        _ref = object.lensFlares;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          flare = _ref[_i];
          flare.x = object.positionScreen.x + vecX * flare.distance;
          flare.y = object.positionScreen.y + vecY * flare.distance;
          flare.rotation = 0;
        }
        object.lensFlares[2].y += 0.025;
        return object.lensFlares[3].rotation = object.positionScreen.x * 0.5 + 45 * Math.PI / 180;
      };
      return null;
    };

    App.prototype.animate = function() {
      window.requestAnimationFrame(this.animate);
      this.render();
      this.stats.update();
    };

    App.prototype.render = function() {
      var delta, _ref;
      delta = this.clock.getDelta();
      this.renderer.clear();
      if (this.controls != null) {
        this.controls.update(delta);
      }
      if ((_ref = this.sph) != null) {
        _ref.position.x = Math.sin(this.clock.oldTime / 1600) * 10;
      }
      this.renderer.render(this.scene, this.camera);
      THREE.AnimationHandler.update(delta);
    };

    App.prototype.onWindowResize = function() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      $("#loading").css({
        'position': 'absolute',
        'width': 400,
        "height": 100,
        'left': window.innerWidth / 2 - 200,
        'top': window.innerHeight / 2 - 50
      });
    };

    return App;

  })();

  $(function() {
    return $(document).ready(function() {
      if (!Detector.webgl || !Detector.workers) {
        return Detector.addGetWebGLMessage();
      } else {
        return new App;
      }
    });
  });

}).call(this);
